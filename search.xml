<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>New Focus 1544光电探测器 手册摘录</title>
      <link href="/2024/10/27/new-focus-1544-guang-dian-tan-ce-qi-shou-ce-zhai-lu/"/>
      <url>/2024/10/27/new-focus-1544-guang-dian-tan-ce-qi-shou-ce-zhai-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-光纤带宽计算公式"><a href="#1-光纤带宽计算公式" class="headerlink" title="1 光纤带宽计算公式"></a>1 光纤带宽计算公式</h2><p><img src="https://s2.loli.net/2024/10/27/GranqXmziMswvZO.png" alt=""></p><h2 id="2-连接器带宽"><a href="#2-连接器带宽" class="headerlink" title="2 连接器带宽"></a>2 连接器带宽</h2><p><img src="https://s2.loli.net/2024/10/27/2HUjq8ni4SyDBzT.png" alt=""><br>Wiltron K即2.92 mm，Wiltron V即1.85 mm</p><hr><p>参考：<br><a href="https://baijiahao.baidu.com/s?id=1738309212838303347&amp;wfr=spider&amp;for=pc">一图区分1.85mm/2.4mm/2.92mm/3.5mm/SMA射频接头</a><br><a href="https://zhuanlan.zhihu.com/p/521535803">射频同轴连接器和电缆指南</a></p>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apparatus, datasheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>频率啁啾的定量理解</title>
      <link href="/2024/09/21/pin-lu-zhou-jiu-de-ding-liang-li-jie/"/>
      <url>/2024/09/21/pin-lu-zhou-jiu-de-ding-liang-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0 简介"></a>0 简介</h2><p>众所周知，在信号路径某点上，信号的时域波形表达式如下:</p><script type="math/tex; mode=display">E_k(t)=\sqrt{I_k(t-t_k)}\exp\{2\pi i[\nu_k(t-t_k)+\beta(t-t_k)^2+\phi_k]\},</script><p>其中$I_k(t)=\exp\{-t^2/2\tau_p^2\}/(\tau_p\sqrt{2\pi})$是强度的时域包络，下图为半高宽$\tau_p=50 ps$的包络：<br><img src="https://s2.loli.net/2024/09/21/3krS9iLTNfKaPCF.jpg" alt=""><br>$\beta$是和频率啁啾有关的量，其量纲为[$1/s^2$]，不难发现可以类比于加速度。实际上，$E_k(t)$的相位项就是人为的泰勒展开。$\varphi(t)=\nu(t-t_k)+\beta(t-t_k)^2+\varphi_k$完全就是匀加速运动中路程表达式的类比：$x = vt+1/2at^2+x_0$，所以$\nu(t) = \nu+2\beta t$，即$\beta$的符号决定$\nu(t)$随时间的增减，进而引出所谓的<strong>正负啁啾</strong>概念。</p><p>然而，有一个值得思考的点是：$v(t) = v+at$可以小于0，即速度方向可以相反，而频率$\nu(t) = \nu+2\beta t$应当总是正的，假如$\beta$足够大使得$\nu(t)$在时间上出现频率0点，那么会怎样？</p><h2 id="1-仿真分析"><a href="#1-仿真分析" class="headerlink" title="1 仿真分析"></a>1 仿真分析</h2><p>由于光频一般都是几百THz的水平，所以1ps内光已经震动了几百次，50ps内线性项震动了近万次，mathematica看不出任何细节，所以这里仿真的光频为0.06THz，这样在±200ps内线性项大概震动20次；另外，由于非线性项为2次，所以$\beta$也要在0.06的基础上除以大约一个仿真时间的数量级以保证mathematica看出细节，这里$\beta$范围先选取为$[-0.001, 0.001]$：<br><img src="https://s2.loli.net/2024/09/21/eGKQR1m9fVCxOIJ.gif" alt="$\nu=0.06$,$\beta∈[-0.001, 0.001]$"></p><p>可以发现，当$\beta$为某一个值时，频率并非我们想的那样随时间单调增加或单调减少。从$\varphi(t)$的图像可以看出频率0点随着$\beta$的变化，这与$E_k(t)$低频项的位移是一致的：<br><img src="https://s2.loli.net/2024/09/21/KZSkwQAI8nXOJUv.gif" alt="$\nu=0.06$,$\beta∈[-0.001, 0.001]$"></p><p>我们再把$\beta$范围缩小为$[-0.0001, 0.0001]$进行仿真，可以发现当$\beta$为某一个值时，频率随随时间单调增加或单调减少了，这种情况就符合我们对于<strong>正负啁啾</strong>概念的认知：<br><img src="https://s2.loli.net/2024/09/21/qO2leNaA7u8BhWf.gif" alt="$\nu=0.06$,$\beta∈[-0.0001, 0.0001]$"><br>这也能从$\varphi(t)$的图像进行解释，其斜率总是单调的：<br><img src="https://s2.loli.net/2024/09/21/NVsCSjq3T9kJOtp.gif" alt="$\nu=0.06$,$\beta∈[-0.0001, 0.0001]$"></p><h2 id="2-实际DFB激光器是哪种情况？"><a href="#2-实际DFB激光器是哪种情况？" class="headerlink" title="2 实际DFB激光器是哪种情况？"></a>2 实际DFB激光器是哪种情况？</h2><p>1550 nm光频大约为193THz，$\beta=0.02 /ps^2$，这样的参数带入mathematca就是一团浆糊。所以这里取出时刻片段200~200.01ps,对$tk$进行扫描以看清波形的细节和全貌：<br><img src="https://s2.loli.net/2024/09/21/xYgrC8aWkqycvwf.gif" alt="$\nu=193$,$\beta=0.02$"><br>观察到：频率几乎不随时间变化。我们可以从$\varphi(t)$图像进一步验证我们的观察：<br><img src="https://s2.loli.net/2024/09/21/XkOhEYDZFwtLpA9.gif" alt="$\nu=193$,$\beta∈[-0.1, 0.1]$"><br>可以发现，斜率变化相当小，即频率变化相当小；另外，即使在$\beta=0.1$这种尺度范围内，频率依然是单调的。所以可以推断，实际中一般不会出现频率为0的情况，但是不排除这种情况能够被物理实现。</p><h2 id="参考文献及代码"><a href="#参考文献及代码" class="headerlink" title="参考文献及代码"></a>参考文献及代码</h2><ol><li>Yuan Z L, Lucamarini M, Dynes J F, et al. Interference of short optical pulses from independent gain-switched laser diodes for quantum secure communications[J]. Physical Review Applied, 2014, 2(6): 064006.</li><li><a href="https://www.wolframcloud.com/obj/wya1759991046/Published/chirp.nb">mathematica笔记本链接</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> optics, signal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自由空间量子信道计算工具</title>
      <link href="/2024/09/16/zi-you-kong-jian-liang-zi-xin-dao-ji-suan-gong-ju/"/>
      <url>/2024/09/16/zi-you-kong-jian-liang-zi-xin-dao-ji-suan-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="功率单位转换器"><a href="#功率单位转换器" class="headerlink" title="功率单位转换器"></a>功率单位转换器</h2><div class="conversion-table">  <div class="table-title">功率单位转换器</div>     <table id="powerconverter" class="display">        <thead>            <tr>                <th>功率 (W)</th>                <th>功率 (dBm)</th>            </tr>        </thead>        <tbody>            <tr>                <td><input type="number" id="wattInput" placeholder="Enter power in W" min="0" step="0.01"></td>                <td><input type="number" id="dbmInput" placeholder="Enter power in dBm"></td>            </tr>        </tbody>    </table></div><script>  // Conversion from Watt to dBm  function convertToDbm() {    let watt = parseFloat(document.getElementById("wattInput").value);    if (!isNaN(watt) && watt > 0) {      let dbm = 10 * Math.log10(watt * 1000);      document.getElementById("dbmInput").value = dbm.toFixed(2);    } else {      document.getElementById("dbmInput").value = "";    }  }  // Conversion from dBm to Watt  function convertToWatt() {    let dbm = parseFloat(document.getElementById("dbmInput").value);    if (!isNaN(dbm)) {      let watt = Math.pow(10, dbm / 10) / 1000;      document.getElementById("wattInput").value = watt.toFixed(9);    } else {      document.getElementById("wattInput").value = "";    }  }  // Add listeners to detect input changes  function addInputListeners() {    document.getElementById("wattInput").addEventListener("input", convertToDbm);    document.getElementById("dbmInput").addEventListener("input", convertToWatt);  }  // Initialization function to set default values (if needed)  function initializeInputs() {    // Optional: Set a default value (initialization)    document.getElementById("wattInput").value = "1"; // Default 1 W    convertToDbm(); // Convert the default watt to dBm on load  }  // Run the initialization and add listeners when the page loads  document.addEventListener("DOMContentLoaded", function() {    initializeInputs(); // Initialize input values    addInputListeners(); // Add event listeners for real-time conversion  });</script><div class="conversion-table">  <div class="table-title">透射率单位转换器</div>     <table id="powerconverter" class="display">        <thead>            <tr>                <th>透射率/损耗</th>                <th>透射率/损耗 (dB)</th>            </tr>        </thead>        <tbody>            <tr>                <td><input type="number" id="transinput" placeholder="Enter power in W" min="0" max="1" step="0.01"></td>                <td><input type="number" id="dbInput" placeholder="Enter power in dBm" max="0"></td>            </tr>        </tbody>    </table></div><script>  // Conversion from Watt to dBm  function transconvertToDbm() {    let watt = parseFloat(document.getElementById("transinput").value);    if (!isNaN(watt) && watt > 0) {      let dbm = 10 * Math.log10(watt);      document.getElementById("dbInput").value = dbm.toFixed(2);    } else {      document.getElementById("dbInput").value = "";    }  }  // Conversion from dBm to Watt  function transconvertToWatt() {    let dbm = parseFloat(document.getElementById("dbInput").value);    if (!isNaN(dbm)) {      let watt = Math.pow(10, dbm / 10);      document.getElementById("transinput").value = watt.toFixed(9);    } else {      document.getElementById("transinput").value = "";    }  }  // Add listeners to detect input changes  function transaddInputListeners() {    document.getElementById("transinput").addEventListener("input", transconvertToDbm);    document.getElementById("dbInput").addEventListener("input", transconvertToWatt);  }  // Initialization function to set default values (if needed)  function transinitializeInputs() {    // Optional: Set a default value (initialization)    document.getElementById("transinput").value = "1"; // Default 1 W    transconvertToDbm(); // Convert the default watt to dBm on load  }  // Run the initialization and add listeners when the page loads  document.addEventListener("DOMContentLoaded", function() {    transinitializeInputs(); // Initialize input values    transaddInputListeners(); // Add event listeners for real-time conversion  });</script><hr><h2 id="光源功率计算器"><a href="#光源功率计算器" class="headerlink" title="光源功率计算器"></a>光源功率计算器</h2><div class="table-container">    <div class="table-title">光源功率计算器</div>    <table id="powerCalculationTable" class="display">        <thead>            <tr>                <th>参数</th>                <th>值</th>            </tr>        </thead>        <tbody>            <tr>                <td>波长 (nm)</td>                <td><input type="number" id="wavelength" value="1550.92" step="0.01"></td>            </tr>            <tr id="photonfrequencyRow">                <td>光子频率 (THz)</td>                <td id="photonfrequency">1.2808177450e-19</td>            </tr>            <tr id="photonEnergyRow">                <td>单光子能量 (J)</td>                <td id="photonEnergy">1.2808177450e-19</td>            </tr>            <tr>                <td>重频 (MHz)</td>                <td><input type="number" id="frequency" value="1250" step="1"></td>            </tr>            <tr>                <td>信号态平均光子数</td>                <td><input type="number" id="signalPhoton" value="0.6" step="0.01"></td>            </tr>            <tr>                <td>信号态占比</td>                <td><input type="number" id="signalRatio" value="0.5" step="0.01"></td>            </tr>            <tr>                <td>诱骗态1平均光子数</td>                <td><input type="number" id="decoy1Photon" value="0.3" step="0.01"></td>            </tr>            <tr>                <td>诱骗态1占比</td>                <td><input type="number" id="decoy1Ratio" value="0.25" step="0.01"></td>            </tr>            <tr>                <td>诱骗态2平均光子数</td>                <td><input type="number" id="decoy2Photon" value="0.0001" step="0.0001"></td>            </tr>            <tr id="decoy2RatioRow">                <td>诱骗态2占比</td>                <td id="decoy2Ratio">0.25</td>            </tr>            <tr id="averagePhotonPulseRow">                <td>平均每脉冲光子数</td>                <td id="averagePhotonPulse">0.375025</td>            </tr>            <tr id="sourcePowerRow">                <td>光源功率 (nW)</td>                <td id="sourcePower">N/A</td>            </tr>            <tr id="sourcePowerdBmRow">                <td>光源功率 (dBm)</td>                <td id="sourcePowerdBm">N/A</td>            </tr>                    </tbody>    </table></div><script>function calculateSinglePhotonEnergy() {    var wavelength = parseFloat(document.getElementById('wavelength').value);    var SinglePhotonEnergy = 6.62607015 * 1e-34 * 299792458/(wavelength*1e-9);    var scientificNotation = SinglePhotonEnergy.toExponential(10);    var photonfrequency  = 299792458/(wavelength * 1e-9)/1e12;    document.getElementById('photonEnergy').innerText = scientificNotation;    document.getElementById('photonfrequency').innerText = photonfrequency.toFixed(4);    return scientificNotation;}function calculatedecoy2Ratio() {    var signalRatio = parseFloat(document.getElementById('signalRatio').value);    var decoy1Ratio = parseFloat(document.getElementById('decoy1Ratio').value);    var decoy2Ratio = 1 - signalRatio - decoy1Ratio;    document.getElementById('decoy2Ratio').innerText = decoy2Ratio.toFixed(2);    return decoy2Ratio;}function calculateAveragePhotonPulse() {    var signalPhoton = parseFloat(document.getElementById('signalPhoton').value);    var signalRatio = parseFloat(document.getElementById('signalRatio').value);    var decoy1Photon = parseFloat(document.getElementById('decoy1Photon').value);    var decoy1Ratio = parseFloat(document.getElementById('decoy1Ratio').value);    var decoy2Photon = parseFloat(document.getElementById('decoy2Photon').value);    var decoy2Ratio = calculatedecoy2Ratio();    // 计算平均每脉冲光子数    var averagePhotonPulse = (signalPhoton * signalRatio) + (decoy1Photon * decoy1Ratio) + (decoy2Photon * decoy2Ratio);    document.getElementById('averagePhotonPulse').innerText = averagePhotonPulse.toFixed(6);    return averagePhotonPulse;}function calculateSourcePower() {    var frequency = parseFloat(document.getElementById('frequency').value);    var photonEnergy = calculateSinglePhotonEnergy();    var averagePhotonPulse = calculateAveragePhotonPulse();    // 计算光源功率    var sourcePower = frequency * 1e6 * photonEnergy * averagePhotonPulse * 1e9;  // 转换为nW    var sourcePowerdBm = 10 * Math.log10(sourcePower * 1e-9 * 1e3);  // 转换为dBm    document.getElementById('sourcePower').innerText = sourcePower.toFixed(6);    document.getElementById('sourcePowerdBm').innerText = sourcePowerdBm.toFixed(4);}// 监听所有输入框的输入事件，实时更新计算结果document.getElementById('wavelength').addEventListener('input', calculateSourcePower);document.getElementById('frequency').addEventListener('input', calculateSourcePower);document.getElementById('signalPhoton').addEventListener('input', calculateSourcePower);document.getElementById('signalRatio').addEventListener('input', calculateSourcePower);document.getElementById('decoy1Photon').addEventListener('input', calculateSourcePower);document.getElementById('decoy1Ratio').addEventListener('input', calculateSourcePower);document.getElementById('decoy2Photon').addEventListener('input', calculateSourcePower);document.getElementById('frequency').addEventListener('input', calculateSourcePower);// 初始化计算calculateSourcePower();</script><hr><h2 id="空间损耗-AB镜间损耗计算器"><a href="#空间损耗-AB镜间损耗计算器" class="headerlink" title="空间损耗/AB镜间损耗计算器"></a>空间损耗/AB镜间损耗计算器</h2><div class="table-container">    <div class="table-title">空间损耗/AB镜间损耗计算器</div>    <table id="lossCalculationTable" class="display">        <thead>            <tr>                <th>参数</th>                <th>值</th>            </tr>        </thead>        <tbody>            <tr>                <td>发散角 (urad)</td>                <td><input type="number" id="divergenceAngle" value="35" min="0" max="100000" step="1"></td>            </tr>            <tr>                <td>通信距离 (km)</td>                <td><input type="number" id="distance" value="30" min="0"></td>            </tr>            <tr>                <td>接收口径 (m)</td>                <td><input type="number" id="receiverDiameter" value="0.28" step="0.02"></td>            </tr>            <tr id="spaceLossRow">                <td>空间损耗</td>                <td id="spaceLoss">0.0711</td>            </tr>            <tr>                <td>大气损耗</td>                <td><input type="number" id="atmosphericLoss" value="0.25" min="0" max="1" step="0.05"></td>            </tr>            <tr id="ABLossRow">                <td>A镜-B镜损耗</td>                <td id="ABLoss">0.0178</td>            </tr>            <tr id="ABLossdBRow">                <td>A镜-B镜损耗（dB）</td>                <td id="ABLossdB">0.0178</td>            </tr>        </tbody>    </table></div><script>function calculateSpaceLoss() {    // 获取用户输入的值    var divergenceAngle = parseFloat(document.getElementById('divergenceAngle').value);    var distance = parseFloat(document.getElementById('distance').value);    var receiverDiameter = parseFloat(document.getElementById('receiverDiameter').value);    var atmosphericLoss = parseFloat(document.getElementById('atmosphericLoss').value);        // 验证发散角是否在 0 到 1 的范围内    if (atmosphericLoss < 0 || atmosphericLoss > 1) {        alert("大气损耗必须在 0 和 1 之间");        return;    }    // 验证输入是否为有效数字    if (!isNaN(divergenceAngle) && !isNaN(distance) && !isNaN(receiverDiameter) && !isNaN(atmosphericLoss)) {        // 计算空间损耗的公式        if (receiverDiameter <= divergenceAngle * distance / 1000){            var spaceLoss = Math.pow((receiverDiameter / (divergenceAngle * distance / 1000)), 2);        }        else {            var spaceLoss = 1;        }        // 计算A镜-B镜损耗的公式        var ABLoss = spaceLoss * atmosphericLoss;        var ABLossdB = 10 * Math.log10(ABLoss);        // 显示结果        document.getElementById('spaceLoss').innerText = spaceLoss.toFixed(4);        document.getElementById('ABLoss').innerText = ABLoss.toFixed(4);        document.getElementById('ABLossdB').innerText = ABLossdB.toFixed(4);    } else {        document.getElementById('spaceLoss').innerText = 'N/A';        document.getElementById('ABLoss').innerText = 'N/A';        document.getElementById('ABLossdB').innerText = 'N/A';    }}// 监听所有输入框的输入事件，实时更新计算结果document.getElementById('divergenceAngle').addEventListener('input', calculateSpaceLoss);document.getElementById('distance').addEventListener('input', calculateSpaceLoss);document.getElementById('receiverDiameter').addEventListener('input', calculateSpaceLoss);document.getElementById('atmosphericLoss').addEventListener('input', calculateSpaceLoss);calculateSpaceLoss();</script><hr><h2 id="B-后光路效率计算器"><a href="#B-后光路效率计算器" class="headerlink" title="B 后光路效率计算器"></a>B 后光路效率计算器</h2><div class="table-container">    <div class="table-title">B 后光路效率计算器</div>    <table id="efficiencyTable" class="display">        <thead>            <tr>                <th>参数</th>                <th>值</th>            </tr>        </thead>        <tbody>            <tr>                <td>接收光学效率</td>                <td><input type="number" id="efficiency1" value="0.6" step="0.01" min="0" max="1"></td>            </tr>            <tr>                <td>接收耦合效率</td>                <td><input type="number" id="efficiency2" value="0.6" step="0.01" min="0" max="1"></td>            </tr>            <tr>                <td>滤波效率</td>                <td><input type="number" id="efficiency3" value="1" step="0.01" min="0" max="1"></td>            </tr>            <tr>                <td>探测器效率</td>                <td><input type="number" id="efficiency4" value="0.2" step="0.01" min="0" max="1"></td>            </tr>            <tr>                <td>门控效率</td>                <td><input type="number" id="efficiency5" value="0.8" step="0.01" min="0" max="1"></td>            </tr>            <tr id="totalEfficiencyRow">                <td>B 后光路总效率</td>                <td id="totalEfficiency">N/A</td>            </tr>            <tr id="totalEfficiencydBRow">                <td>B 后光路总效率（dB）</td>                <td id="totalEfficiencydB">N/A</td>            </tr>                   </tbody>    </table></div><script>function calculateTotalEfficiency() {    // 获取用户输入的效率值    var efficiency1 = parseFloat(document.getElementById('efficiency1').value);    var efficiency2 = parseFloat(document.getElementById('efficiency2').value);    var efficiency3 = parseFloat(document.getElementById('efficiency3').value);    var efficiency4 = parseFloat(document.getElementById('efficiency4').value);    var efficiency5 = parseFloat(document.getElementById('efficiency5').value);    // 验证输入是否为有效数字    if (!isNaN(efficiency1) && !isNaN(efficiency2) && !isNaN(efficiency3) &&        !isNaN(efficiency4) && !isNaN(efficiency5)) {        // 计算 B 后光路总效率        var totalEfficiency = efficiency1 * efficiency2 * efficiency3 * efficiency4 * efficiency5;        var totalEfficiencydB = 10 * Math.log10(totalEfficiency);        // 显示结果        document.getElementById('totalEfficiency').innerText = totalEfficiency.toFixed(4);        document.getElementById('totalEfficiencydB').innerText = totalEfficiencydB.toFixed(2);    } else {        document.getElementById('totalEfficiency').innerText = 'N/A';        document.getElementById('totalEfficiencydB').innerText = 'N/A';    }}// 监听所有输入框的输入事件，实时更新计算结果document.getElementById('efficiency1').addEventListener('input', calculateTotalEfficiency);document.getElementById('efficiency2').addEventListener('input', calculateTotalEfficiency);document.getElementById('efficiency3').addEventListener('input', calculateTotalEfficiency);document.getElementById('efficiency4').addEventListener('input', calculateTotalEfficiency);document.getElementById('efficiency5').addEventListener('input', calculateTotalEfficiency);// 初始化计算calculateTotalEfficiency();</script><hr><h2 id="B-QBER计算器"><a href="#B-QBER计算器" class="headerlink" title="B QBER计算器"></a>B QBER计算器</h2><div class="table-container">    <div class="table-title">B QBER计算器</div>    <table id="eventTable" class="display">        <thead>            <tr>                <th>参数</th>                <th>值</th>            </tr>        </thead>        <tbody>            <tr>                <td>重频 (MHz)</td>                <td><input type="number" id="frequency1" value="1250" step="1" min="0"></td>            </tr>            <tr>                <td>信号态平均光子数</td>                <td><input type="number" id="avgPhotonCount" value="0.6" step="0.01" min="0"></td>            </tr>            <tr>                <td>信号态占比</td>                <td><input type="number" id="signalRatio1" value="0.5" step="0.01" min="0" max="1"></td>            </tr>            <tr>                <td>总损耗</td>                <td><input type="number" id="totalLoss" value="0.01" step="0.001" min="0" max="1"></td>            </tr>            <tr id="eventCountRow">                <td>B 探测到信号态事件数（Hz）</td>                <td id="eventCount">N/A</td>            </tr>            <tr>                <td>B 4路探测器噪声（Hz）</td>                <td><input type="number" id="detnoise" value="800" step="1" min="0"></td>            </tr>            <tr>                <td>B 环境噪声（Hz）</td>                <td><input type="number" id="envirnoise" value="1000" step="1" min="0"></td>            </tr>            <tr id="totalnoiseRow">                <td>B 总噪声（Hz）</td>                <td id="totalnoise">N/A</td>            </tr>            <tr id="noiseBERRow">                <td>噪声误码率（B 总噪声引入的错误/B 总计数）</td>                <td id="noiseBER">N/A</td>            </tr>            <tr>                <td>偏振误码率（B 信号态偏振误码数/B 信号态事件数）</td>                <td><input type="number" id="PBER" value="0.005" step="0.001" min="0" max="1"></td>            </tr>            <tr id="QBERRow">                <td>总误码率</td>                <td id="QBER">N/A</td>            </tr>        </tbody>    </table></div><script>function calculateQBER() {    // 获取用户输入的效率值    var frequency1 = parseFloat(document.getElementById('frequency1').value);    var avgPhotonCount = parseFloat(document.getElementById('avgPhotonCount').value);    var signalRatio1 = parseFloat(document.getElementById('signalRatio1').value);    var totalLoss = parseFloat(document.getElementById('totalLoss').value);    var detnoise = parseFloat(document.getElementById('detnoise').value);    var envirnoise = parseFloat(document.getElementById('envirnoise').value);    var PBER = parseFloat(document.getElementById('PBER').value);    // 验证输入是否为有效数字    if (!isNaN(frequency1) && !isNaN(avgPhotonCount) && !isNaN(signalRatio1) && !isNaN(totalLoss) && !isNaN(detnoise) && !isNaN(envirnoise) &&        !isNaN(PBER)) {        // 计算 B 后光路总效率        var eventCount = frequency1 * 1e6 * signalRatio1 * (1 - Math.exp(-totalLoss*avgPhotonCount));        var totalnoise = detnoise + envirnoise;        var noiseBER = totalnoise/4/2/(totalnoise + eventCount);        var QBER = (totalnoise/4/2 + PBER * eventCount)/(totalnoise + eventCount);        // 显示结果        document.getElementById('eventCount').innerText = eventCount.toFixed(0);        document.getElementById('totalnoise').innerText = totalnoise.toFixed(0);        document.getElementById('noiseBER').innerText = noiseBER.toFixed(6);        document.getElementById('QBER').innerText = QBER.toFixed(6);    } else {        document.getElementById('eventCount').innerText = 'N/A';        document.getElementById('totalnoise').innerText = 'N/A';        document.getElementById('noiseBER').innerText = 'N/A';        document.getElementById('QBER').innerText = 'N/A';    }}// 监听所有输入框的输入事件，实时更新计算结果document.getElementById('frequency1').addEventListener('input', calculateQBER);document.getElementById('avgPhotonCount').addEventListener('input', calculateQBER);document.getElementById('signalRatio1').addEventListener('input', calculateQBER);document.getElementById('totalLoss').addEventListener('input', calculateQBER);document.getElementById('detnoise').addEventListener('input', calculateQBER);document.getElementById('envirnoise').addEventListener('input', calculateQBER);document.getElementById('PBER').addEventListener('input', calculateQBER);// 初始化计算calculateQBER();</script><style>.table-container {    padding: 20px;    margin: 0 auto; /* 表格容器居中 */    text-align: left; /* 让内容居中 */}.table-title {    font-size: 20px;    font-weight: bold;    text-align: left;}table {    table-layout: fixed; /* 固定表格布局 */    width: 100%; /* 设置表格宽度 */    border-collapse: collapse;    margin: 0 auto; /* 表格居中 */}th, td {    border: 1px solid #ddd;    padding: 10px;    text-align: center;    width: 65%;}#photonEnergyRow, #decoy2RatioRow, #averagePhotonPulseRow, #photonfrequencyRow,#sourcePowerRow, #sourcePowerdBmRow, #spaceLossRow, #ABLossRow,#ABLossdBRow,#totalEfficiencyRow, #totalEfficiencydBRow,#eventCountRow, #totalnoiseRow, #noiseBERRow, #QBERRow {    background-color: skyblue;}</style>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool, QKD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>角度⇔弧度</title>
      <link href="/2024/09/16/jiao-du-hu-du/"/>
      <url>/2024/09/16/jiao-du-hu-du/</url>
      
        <content type="html"><![CDATA[<h2 id="角度⇔弧度转换器"><a href="#角度⇔弧度转换器" class="headerlink" title="角度⇔弧度转换器"></a>角度⇔弧度转换器</h2><div class="table-container">    <div class="table-title">角度⇔弧度转换器</div>    <table id="conversionTable" class="display">        <thead>            <tr>                <th>角度 (°)</th>                <th>弧度 (rad)</th>            </tr>        </thead>        <tbody>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>        </tbody>    </table></div><style>.table-container {    padding: 20px;}.table-title {    font-size: 20px;    font-weight: bold;    text-align: left;}table {    border-collapse: collapse;    border-radius: 10px;    width: 100%;}th, td {    border: 1px solid #ddd;    padding: 10px;    text-align: center;    width: 50%;}</style><script>$(document).ready(function() {    // 角度转换为弧度的函数    function toRadians(angle) {        return (angle * Math.PI / 180).toFixed(7);    }    // 弧度转换为角度的函数    function toDegrees(radian) {        return (radian * 180 / Math.PI).toFixed(5);    }    // 监听角度输入框的输入事件，实时转换为弧度    $('.angle-input').on('input', function() {        var angleValue = parseFloat($(this).val());        if (!isNaN(angleValue)) {            var radianValue = toRadians(angleValue);            $(this).closest('tr').find('.radian-input').val(radianValue);        } else {            $(this).closest('tr').find('.radian-input').val('');        }    });    // 监听弧度输入框的输入事件，实时转换为角度    $('.radian-input').on('input', function() {        var radianValue = parseFloat($(this).val());        if (!isNaN(radianValue)) {            var angleValue = toDegrees(radianValue);            $(this).closest('tr').find('.angle-input').val(angleValue);        } else {            $(this).closest('tr').find('.angle-input').val('');        }    });});</script>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool, convert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河边</title>
      <link href="/2024/08/26/he-bian/"/>
      <url>/2024/08/26/he-bian/</url>
      
        <content type="html"><![CDATA[<h2 id="20240825"><a href="#20240825" class="headerlink" title="20240825"></a>20240825</h2><p><img src="https://s2.loli.net/2024/08/26/XuwYdfnb6DmsORz.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/5lAO4YUviqGXSrx.jpg" alt=""></p><h2 id="20220628"><a href="#20220628" class="headerlink" title="20220628"></a>20220628</h2><p><img src="https://s2.loli.net/2024/08/26/Pz5SC7qoawYky9r.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/2ZtopRHqO6zsAEl.jpg" alt=""></p><h2 id="20210831"><a href="#20210831" class="headerlink" title="20210831"></a>20210831</h2><p><img src="https://s2.loli.net/2024/08/26/3XkPQ1N65DMVAEH.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/azZHe3huqfpQBvw.jpg" alt=""></p><h2 id="20200822"><a href="#20200822" class="headerlink" title="20200822"></a>20200822</h2><p><img src="https://s2.loli.net/2024/08/26/lMzjiGQ4VrdqPgb.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/ypNm3YCHLirS7UW.jpg" alt=""></p><h2 id="20190821"><a href="#20190821" class="headerlink" title="20190821"></a>20190821</h2><p><img src="https://s2.loli.net/2024/08/26/8nqRFcKMtCYy56X.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/m5FYEHWNLIi6wMq.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> vision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary, landscape </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thorlabs PAX1000不准直会发生的现象及原因探寻</title>
      <link href="/2024/08/21/thorlabs-pax1000-bu-zhun-zhi-hui-fa-sheng-de-xian-xiang-ji-yuan-yin-tan-xun/"/>
      <url>/2024/08/21/thorlabs-pax1000-bu-zhun-zhi-hui-fa-sheng-de-xian-xiang-ji-yuan-yin-tan-xun/</url>
      
        <content type="html"><![CDATA[<h2 id="0-现象"><a href="#0-现象" class="headerlink" title="0 现象"></a>0 现象</h2><ol><li><p>前几天使用matlab visa库控制PAX1000测试光芯片偏振调制时，发现偏振输出会在邦加球上两条调制曲线之间无规律横跳：<br><img src="https://s2.loli.net/2024/08/21/WomscDVfxU8qrlH.png" alt=""><br>固定某个调制电压，发现偏振态会在两个邦加球两点之间无规律横跳。</p></li><li><p>为了排除光芯片的原因，我直接向PAX1000打入单模耦合输入的偏振光（正确做法是拿保偏接，但是单模短时间内偏振变化不会太大），记录120s内visa以1Hz速率传输的数据和120s中某一时刻PAX1000自带软件的截图，可以发现：</p></li></ol><ul><li>使用matlab visa库读取的方位角(Azimuth θ)、椭圆率角(Ellipticity η)会横跳；</li><li>使用PAX1000自带软件测试不会横跳；</li><li>PAX1000自带软件数据在横跳数据之间，但不是正中间。</li></ul><p><img src="https://s2.loli.net/2024/08/21/ROHPFrzL8yIShW4.jpg" alt="visa传输数据"><br><img src="https://s2.loli.net/2024/08/21/MrA7OFbKNexI5LE.png" alt="PAX1000软件数据"></p><h2 id="1-朔源"><a href="#1-朔源" class="headerlink" title="1 朔源"></a>1 朔源</h2><p>查阅手册发现原因可能是前些天准直器松动后我重新固定了，但是没有准直。而没有准直会出现以下问题，即引入奇数次谐波：<br><em>“The angular alignment is critical for another reason: As explained in the section Rotating Waveplate Technique , the photo current is analyzed by a Fast Fourier Transformation and ideally<br>consists only of even-numbered components (harmonics). If the beam hits the waveplate not<br>exactly perpendicular, unwanted odd-numbered harmonics will appear in the photo current. The<br>same happens, if the incident beam consists reflected from the inner surface of the hollow shaft<br>light components. These unwanted components have a significant impact on the measurement<br>accuracy. The Alignment Assistance tool can be used to align the beam, which will minimize<br>the contribution from unwanted components.”</em></p><p>于是我手动准直了一下PAX1000，发现数据反复横跳的现象确实消失了，且visa读出数据与软件数据完全吻合。然而，为什么不准直会引入奇数次谐振？为了解释这个问题，我们首先要知道PAX1000的工作原理。<br><img src="https://s2.loli.net/2024/08/21/ALkfWGJZsV4NHmo.png" alt="FOURIER ANALYSIS USING A ROTATING QUARTER-WAVE RETARDER"><br>由于PAX1000使用了上世纪的旋转波片技术，所以随便翻一本经典的偏振书籍就能找到解释：不同的偏振光经过旋转1/4波片及固定极化片，再经过光电探测可以得到随时间变化的光电流</p><script type="math/tex; mode=display">I(\theta)=\frac{1}{2}\left[\left(S_{0}+\frac{S_{1}}{2}\right)+\frac{S_{1}}{2}\cos4\theta+\frac{S_{2}}{2}\sin4\theta-S_{3}\sin2\theta\right]\\=\frac{1}{2}[A-B\sin2\omega t+C\cos4\omega t+D\sin4\omega t]</script><p>这是傅里叶展开，于是可以通过积分算系数，再解方程求偏振参数：</p><script type="math/tex; mode=display">\begin{aligned}&A=\frac1\pi\int_0^{2\pi}I(\theta) d\theta\\&B=\frac2\pi\int_0^{2\pi}I(\theta)\sin2\theta d\theta\\&C=\frac2\pi\int_0^{2\pi}I(\theta)\cos4\theta d\theta\\&D=\frac2\pi\int_0^{2\pi}I(\theta)\sin4\theta d\theta\end{aligned}</script><p>由于现实中没有积分器，于是采样并求和，就得到了PAX1000的数据处理方法：</p><script type="math/tex; mode=display">\begin{aligned}A & =\frac{2}{N} \sum_{n=1}^{N} I\left(n \theta_{j}\right) \\B & =\frac{4}{N} \sum_{n=1}^{N} I\left(n \theta_{j}\right) \sin 2 n \theta_{j} \\C & =\frac{4}{N} \sum_{n=1}^{N} I\left(n \theta_{j}\right) \cos 4 n \theta_{j} \\D & =\frac{4}{N} \sum_{n=1}^{N} I\left(n \theta_{j}\right) \sin 4 n \theta_{j}\end{aligned}</script><p>这个表达式里面确实只有偶数项，那奇数项会从哪里引入呢？另外，为什么只在两个值之间横跳？再仔细翻阅手册，可以发现这么一段话：<br><em>“The photo current measured during this half turn is analyzed by a Fast Fourier Transformation (FFT). By default, the FFT “splits” the data into 512 measurement points (ADC values).”</em><br>好家伙，难道用visa时我只用了半圈去计算？于是我试了下将软件调成以半圈为周期计算，结果还真是反复横跳，且相当规律：<br><img src="https://s2.loli.net/2024/08/21/Mgs3olvm2ZYaUiz.png" alt=""><br>这样一来，我们要解决的问题就变成了：<br><strong>当没准直时，且使用半圈去计算时，为什么偏振结果会跳变？</strong></p><h2 id="2-原因"><a href="#2-原因" class="headerlink" title="2 原因"></a>2 原因</h2><p>当没有准直时，光线即使斜入射波片，也不会造成前半圈和后半圈结果不同，所以不对称很可能来源于波片瑕疵。然而，假如确实是由波片不完美导致的，由于旋转过程中光束落点处波片厚度不同，那么准直入射的情况也应该显现出偏振跳变。实际情况是，只有未准直的光束显现出了偏振跳变，所以肯定不是由于波片瑕疵导致的。</p><p>在查阅文献后，我找到了可能的问题来源：实际情况中，波片平面与其旋转轴肯定不是完美垂直，而是存在一个角度”Wobble”，而当波片高速转动时，由于离心力这个角度放大。<br><img src="https://s2.loli.net/2024/08/24/TELMOl4NrndsxGf.png" alt=""></p><p>为了说明”Wobble”可能导致偏振跳变的情况，我们分别考察准直和不准直的两种情况：</p><ol><li><p>准直时，在波片旋转的过程中，入射光线和主轴的夹角不会发生任何改变。这里用mathematica做了一个动画演示，其中蓝色向量代表入射光线，灰色圆盘代表波片，绿线代表波片主轴，红色向量代表波片法向，设置”Wobble”=30°。另外，我画出了旋转过程中入射光线和主轴的夹角。可以发现，在波片旋转过程中夹角不发生任何改变：<br><img src="https://s2.loli.net/2024/08/24/Krf4chJQsN5eZyC.gif" alt=""><br><img src="https://s2.loli.net/2024/08/24/naWjO94UV7oFbAu.jpg" alt=""><br>另外，稍微想一下也会发现光束落点也不会影响半圈一致性。</p></li><li><p>不准直时，入射光线和主轴的夹角发现改变，<strong>且有99.9999…%的可能性使半圈对称性“破缺”</strong>。这里同样做了动画演示，配置同上，入射光线偏斜45°。可以发现，在波片旋转中入射光线和主轴的夹角一直在变化，且前半圈和后半圈不具有对称性：<br><img src="https://s2.loli.net/2024/08/24/gF76ZanpXhoWCPN.gif" alt=""><br><img src="https://s2.loli.net/2024/08/24/euv4PGfCcyLYMjI.jpg" alt=""></p></li></ol><p><strong>然而有一种特殊情况不会导致对称性“破缺”</strong>，这种情况几乎不可能发生，这种情况下主轴在旋转时不会于准直入射方向发生夹角的改变，因此等价于光束斜入射”Wobble”=0°的波片。<br><img src="https://s2.loli.net/2024/08/24/o89mFNbqZuvjrQy.gif" alt=""><br><img src="https://s2.loli.net/2024/08/24/zUNAyhmxWaFwSG5.jpg" alt=""></p><h2 id="3-闭环"><a href="#3-闭环" class="headerlink" title="3 闭环"></a>3 闭环</h2><ol><li>没准值时visa偏振跳变是由于没有下发整数圈数据处理的指令。</li><li>准直时用半圈处理数据不会导致偏振跳变。</li><li>理想/非理想情况下(当不存在/存在wobble时)，准直且用用半圈处理数据不会导致偏振跳变。</li><li>理想情况下(当不存在wobble时)，没准直且用用半圈处理数据不会导致偏振跳变。</li><li>非理想情况下(当存在wobble时)，没准直且用用半圈处理数据会导致偏振跳变。</li><li><strong>手册中不准值时引入奇数项的具体含义是：光强中不仅有二次项（半圈）以及四次项（1/4圈）存在了，还引入了一次项（1圈）</strong>。</li></ol><h2 id="参考文献及代码链接"><a href="#参考文献及代码链接" class="headerlink" title="参考文献及代码链接"></a>参考文献及代码链接</h2><ol><li>Williams P A. Rotating-wave-plate Stokes polarimeter for differential group delay measurements of polarization-mode dispersion[J]. Applied optics, 1999, 38(31): 6508-6515.</li><li><a href="https://www.wolframcloud.com/obj/wya1759991046/Published/pax1000simu.nb">mathematica笔记本链接</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apparatus, polarization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>叠层阻抗表</title>
      <link href="/2024/07/30/die-ceng-zu-kang/"/>
      <url>/2024/07/30/die-ceng-zu-kang/</url>
      
        <content type="html"><![CDATA[<p>这是一张14层的叠层阻抗表，黄色标注了1-4层的三阶盲埋：<br><img src="https://s2.loli.net/2024/07/30/D9UOSApXMT4EBdj.png" alt=""><br><strong>注：FR4图中写错，FR4 = Fire Resist level4，是一种防火等级，因为PCB需要有主动阻燃性，所以需要FR4材料。FR4一般都指core(芯板)中间黄色部分，其厚度为规定值，以core形态成品售往PCB工厂，所以FR4一般也指core。PP(prepreg，又称半固化片)也属于FR4，只不过部分固化，PCB 制造商使用它来将蚀刻芯粘合在一起。可参考：<a href="https://electronics.stackexchange.com/questions/356063/what-exactly-is-prepreg-and-core-in-a-pcb">What exactly is prepreg and core in a PCB?</a></strong></p><p>与阻抗计算工具的结果吻合：<br><img src="https://s2.loli.net/2024/07/30/JCwgvN4IMdceSlb.png" alt=""><br><img src="https://s2.loli.net/2024/07/30/xoYAMfbRiZKE2pu.png" alt=""></p><hr><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/512495251">PCB板材的基础知识</a><br><a href="https://baijiahao.baidu.com/s?id=1787683941435650876&amp;wfr=spider&amp;for=pc">高速PCB的铜箔选用指南</a><br><a href="https://www.sunshinepcb.com/news/knowledge/81.html">PCB叠层设计指南 | 从材料选型到叠构设计</a><br><a href="https://www.protoexpress.com/tools/pcb-impedance-calculator/">Impedance Calculator</a><br>附12层叠层阻抗表：<br><img src="https://s2.loli.net/2024/08/19/ShYKyzBtGqRonud.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electronic, PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project · JZ 存储器备忘录</title>
      <link href="/2024/07/29/project-jz-cun-chu-qi-bei-wang-lu/"/>
      <url>/2024/07/29/project-jz-cun-chu-qi-bei-wang-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="0-动机"><a href="#0-动机" class="headerlink" title="0 动机"></a>0 动机</h2><p>Datasheet太多了，点开文件夹查找过于麻烦。作为记性不好又懒得一匹的包工头，不需要动脑写逻辑，只需要了解关键内容。因此摘录sheet要点并加上芯片架构层面的内容和思考，不包含时序和芯片自带功能（例如NAND、MRAM的ECC）的解读，作为一个快捷的备忘录。</p><h2 id="1-DDR2"><a href="#1-DDR2" class="headerlink" title="1 DDR2"></a>1 DDR2</h2><ul><li><p>型号：ISSI(芯成 · 美) IS43DR16128C<br>容量：2Gb = 128M$\times$16b = 8(banks)$\times$16M$\times$16b；<br>位宽：16b<br><img src="https://s2.loli.net/2024/07/29/VRjSW17Zmr9sGYg.png" alt=""><br>速率等ORDER INFO：<br><img src="https://s2.loli.net/2024/07/29/HA2tI3F4SPLQrNz.png" alt=""></p></li><li><p>特征参数<br><img src="https://s2.loli.net/2024/07/29/8ynSs1dVxYEO2jW.png" alt=""></p></li><li><p>架构<br><img src="https://s2.loli.net/2024/07/29/Jh42Vz1vXlWRQOr.png" alt=""></p></li><li><p>管脚<br><img src="https://s2.loli.net/2024/07/29/tmMiAjwrGXa3obW.png" alt=""><br><img src="https://s2.loli.net/2024/07/29/ohdg3EtqW29fGaD.png" alt=""><br>管脚特征：<br>没有读使能信号，读使能是通过拉高写使能。<br>DDR2不像NAND FLASH一样复用IO可能是因为要求高速。<br>DM掩码某些数据位，而DQS有效化某些数据时刻，作用不一样。</p></li></ul><h2 id="2-NAND-FLASH"><a href="#2-NAND-FLASH" class="headerlink" title="2 NAND FLASH"></a>2 NAND FLASH</h2><ul><li><p>型号：MICRON(美光 · 美) MT29F128G08AMCABH2<br>容量：128Gb = 16384(块)$\times$128(页)$\times$8640B；<br>位宽：8b<br><img src="https://s2.loli.net/2024/07/29/xcMjmuVCUGFgHfk.png" alt=""></p></li><li><p>特征参数<br><img src="https://s2.loli.net/2024/07/29/ujJgxMwW1hY2RU7.png" alt=""><br>注意，NAND手册一般不会给出工作在同步模式下的时钟频率。</p></li><li><p>架构<br><img src="https://s2.loli.net/2024/07/29/8kyEAR1xzLZG6Ma.png" alt=""><br><img src="https://s2.loli.net/2024/07/29/lNm5boGgRK1fX6h.png" alt=""><br>MT29F128G08AMCABH2有4个LUN。</p></li><li><p>管脚<br><img src="https://s2.loli.net/2024/07/29/DoIMucBGz98Leth.png" alt=""><br>为什么这样分配管脚：<br><strong><em>比如命令锁存使能(Command Latch Enable,CLE)和地址锁存使能(Address Latch Enable，ALE)，那是因为，Nand Flash就8个I/O，而且是复用的，也就是，可以传数据，也可以传地址，也可以传命令，为了区分…</em></strong><br><strong><em>Nand flash支持一个叫做CE(chip enable) don’t-care的技术…由于某些外部应用的频率比较低，而Nand Flash内部操作速度比较快…节省功耗…</em></strong><br>参考：<a href="https://zhuanlan.zhihu.com/p/340496845">智能座舱之存储篇第三篇—-NAND Flash 一眼就看明白了</a></p></li><li><p>LUN寻址规则<br><img src="https://s2.loli.net/2024/07/29/Fs5zOQhwPALX26W.png" alt=""></p></li></ul><h2 id="3-QSPI-FLASH"><a href="#3-QSPI-FLASH" class="headerlink" title="3 QSPI FLASH"></a>3 QSPI FLASH</h2><ul><li><p>型号：Infineon(原厂Cypress，2019年被Infineon收购 · 美) S25FL128S<br>容量：128Mb<br>位宽：4b<br><img src="https://s2.loli.net/2024/07/30/M1EioZbzukJIBsL.png" alt=""><br><strong>EHPLC（Enhanced High-Performance Low Command Mode）增强型高性能低命令模式</strong>：<br>功能：EHPLC 模式专注于在最低的命令开销下提供最高的数据传输速率。通过优化命令和数据传输过程，EHPLC 模式能够实现更高的性能，特别是在需要快速读取大量数据的应用中。<br>特点：EHPLC 模式可能会使用更高效的命令集和协议来减少延迟和增加吞吐量，从而提供比传统模式更高的性能。<br><strong>HPLC（High-Performance Low Command Mode）高性能低命令模式</strong>：<br>功能：HPLC 模式也致力于提高数据传输速率，但与 EHPLC 相比，其优化程度可能稍低。HPLC 仍然通过减少命令开销和提高数据传输效率来提供良好的性能。<br>特点：HPLC 模式通常在标准 QSPI 操作的基础上进行一些优化，使其适用于大多数高性能应用，但可能不如 EHPLC 那样极致优化。</p></li><li><p>特征参数<br>注意，这个手册block块=sector扇区<br><img src="https://s2.loli.net/2024/07/30/gMQRPDeht2Ak146.png" alt=""></p></li><li><p>架构<br><img src="https://s2.loli.net/2024/07/30/3FP1fSiHJnlteUG.png" alt=""><br>非常草率的架构图。。。<br><img src="https://s2.loli.net/2024/07/30/OARVLNiy12acW4g.png" alt=""></p></li><li><p>管脚<br><img src="https://s2.loli.net/2024/07/30/M5eVJZ9mFQrfE8z.png" alt=""><br>类似于NAND，QUAD模式4个IO复用指令、地址、数据，并且时分传递。</p></li></ul><h2 id="4-MRAM"><a href="#4-MRAM" class="headerlink" title="4 MRAM"></a>4 MRAM</h2><ul><li><p>型号：EVERSPIN(埃弗斯平 · 美，只做MRAM的小公司，从随意的中文名就可以看出) MR5A16ACYS35<br>容量：32Mb；位宽：16b<br><img src="https://s2.loli.net/2024/07/29/kbTa9m7tzepWUBv.png" alt=""></p></li><li><p>特征参数<br><img src="https://s2.loli.net/2024/07/29/oVRBMi3vUqcyWJe.png" alt=""></p></li><li><p>架构<br><img src="https://s2.loli.net/2024/07/29/tOnjAXr8vdWDmVx.png" alt=""><br>架构图非常简单清晰。<br>“sense amps”（感应放大器）是用来检测和放大存储单元中的信号电压的电路。这些感应放大器的作用是读取MRAM单元的状态，即确定存储单元中存储的是0还是1。具体来说，MRAM的存储单元通过磁性材料的磁化方向来表示数据，而感应放大器则通过检测这些磁化方向造成的电压变化来读取数据。</p></li><li><p>管脚<br><img src="https://s2.loli.net/2024/07/29/TRfj4amweL7qxQg.png" alt=""><br>Output Enable和Write Enable相当于外部输入的读写使能信号。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electronic, memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DJI mini4K拍照模式测试</title>
      <link href="/2024/07/28/dji-mini4k-pai-zhao-mo-shi-ce-shi/"/>
      <url>/2024/07/28/dji-mini4k-pai-zhao-mo-shi-ce-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>主要是天气不错，但是出去骑车又很热，于是闲着没事玩玩mini4K几种照相模式，而且台风格美过境后风力不错，目测偶尔有六级以上，所以作死测试一下其抗风能力。</p><ul><li>全景</li></ul><p>使用这个7年前就断更的开源插件hexo-tag-panoview：<br></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">$ npm install hexo<span class="token operator">-</span>tag<span class="token operator">-</span>panoview <span class="token operator">--</span>save</code></pre><p></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">{</span><span class="token operator">%</span> panoview <span class="token string">"https://s2.loli.net/2024/07/28/QkJsBRyWpc3ECH8.jpg"</span> <span class="token number">400</span> <span class="token number">790</span> <span class="token operator">%</span><span class="token punctuation">}</span><span class="token comment">//400 是指全景的高度；</span><span class="token comment">//790 是指全景的宽度。</span><span class="token punctuation">{</span><span class="token operator">%</span> endpanoview <span class="token operator">%</span><span class="token punctuation">}</span></code></pre><p>得到图片：<br></p><div id="panoview6750" style="margin: 0 auto"></div><script src="https://unpkg.com/three@0.88.0/build/three.min.js"></script><script>    var camera, scene, renderer;    var isUserInteracting = false,        onMouseDownMouseX = 0, onMouseDownMouseY = 0,        lon = 0, onMouseDownLon = 0,        lat = 0, onMouseDownLat = 0,        phi = 0, theta = 0;    init();    animate();    function init() {        var container, mesh;        container = document.getElementById('panoview6750');        var width = container.style.width;        camera = new THREE.PerspectiveCamera(75, 2, 1, 1000);        camera.target = new THREE.Vector3(0, 0, 0);        scene = new THREE.Scene();        var geometry = new THREE.SphereBufferGeometry(500, 60, 40);        // invert the geometry on the x-axis so that all of the faces point inward        geometry.scale(- 1, 1, 1);        var material = new THREE.MeshBasicMaterial({            map: new THREE.TextureLoader().load('https://s2.loli.net/2024/07/28/QkJsBRyWpc3ECH8.jpg')        });        mesh = new THREE.Mesh(geometry, material);        scene.add(mesh);        renderer = new THREE.WebGLRenderer();        renderer.setPixelRatio(window.devicePixelRatio);        renderer.setSize(window.innerWidth, window.innerHeight);        renderer.domElement.style.width = "790px";        renderer.domElement.style.height = "400px";        container.appendChild(renderer.domElement);        container.addEventListener('mousedown', onDocumentMouseDown, false);        container.addEventListener('mousemove', onDocumentMouseMove, false);        container.addEventListener('mouseup', onDocumentMouseUp, false);        // container.addEventListener('wheel', onDocumentMouseWheel, false);        container.addEventListener('dragover', function (event) {            event.preventDefault();            event.dataTransfer.dropEffect = 'copy';        }, false);        container.addEventListener('dragenter', function (event) {            document.body.style.opacity = 0.5;        }, false);        container.addEventListener('dragleave', function (event) {            document.body.style.opacity = 1;        }, false);    }    function onDocumentMouseDown(event) {        event.preventDefault();        isUserInteracting = true;        onMouseDownMouseX = event.clientX;        onMouseDownMouseY = event.clientY;        onMouseDownLon = lon;        onMouseDownLat = lat;    }    function onDocumentMouseMove(event) {        if (isUserInteracting === true) {            lon = (onMouseDownMouseX - event.clientX) * 0.1 + onMouseDownLon;            lat = (event.clientY - onMouseDownMouseY) * 0.1 + onMouseDownLat;        }    }    function onDocumentMouseUp(event) {        isUserInteracting = false;    }    function onDocumentMouseWheel(event) {        var fov = camera.fov + event.deltaY * 0.05;        camera.fov = THREE.Math.clamp(fov, 10, 75);        camera.updateProjectionMatrix();        return false;    }    function animate() {        requestAnimationFrame(animate);        update();    }    function update() {        if (isUserInteracting === false) {            lon += 0.1;        }        lat = Math.max(- 85, Math.min(85, lat));        phi = THREE.Math.degToRad(90 - lat);        theta = THREE.Math.degToRad(lon);        camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);        camera.target.y = 500 * Math.cos(phi);        camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);        camera.lookAt(camera.target);        /*        // distortion        camera.position.copy( camera.target ).negate();        */        renderer.render(scene, camera);    }</script><p></p><p>对比无全景效果，效果居然还不错：<br><img src="https://s2.loli.net/2024/07/28/QkJsBRyWpc3ECH8.jpg" alt=""></p><ul><li>180°</li></ul><p><img src="https://s2.loli.net/2024/07/28/CbeE5f7PvIyTOxX.jpg" alt=""></p><ul><li>广角</li></ul><p><img src="https://s2.loli.net/2024/07/28/R72NqPUspjJzlEA.jpg" alt=""></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>mini4K 1/2.3’’小尺寸CMOS应对广角及以上照片的拍摄方法是分时定位拍摄算法合成</li><li>mini4K抗6级风问题不大</li></ul>]]></content>
      
      
      <categories>
          
          <category> toy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> drone, mini4K </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Using Mathematica for QM  one particle in one dimension (1)</title>
      <link href="/2024/07/28/using-mathematica-for-qm-one-particle-in-one-dimension-1/"/>
      <url>/2024/07/28/using-mathematica-for-qm-one-particle-in-one-dimension-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0-动机"><a href="#0-动机" class="headerlink" title="0 动机"></a>0 动机</h2><p>追求静态网页支持在线mathematica是个错误的方向，直接将笔记上传至mathematica云端就行。但是mathematica的排版一直很难用，就算调用matex包，mathematica依然对latex语言支持很差劲。经过尝试，意外发现它对MathML脚本支持比较完善。另外，将枯燥的standardform转换为traditionalform可以将代码语言转换成公式语言，一定程度上能增加代码可读性。</p><p>然而，一些mathematica的动态或静态图片结果不会加载在云端，需要在云端运行或者下载到本地运行，这就比较麻烦。</p><p><strong>因此，主页放上要点和结论性的图片，同时附上mathematica笔记本链接，会是一个不错的结合。</strong></p><p><a href="https://www.wolframcloud.com/env/wya1759991046/Published/Use%20mathematica%20for%20QM%204.1.1_4.1.6.nb">mathematica笔记本链接</a></p><h2 id="1-要点"><a href="#1-要点" class="headerlink" title="1 要点"></a>1 要点</h2><ul><li>finite-resolution position basis(FRPS/PS)本质上是对Dirac basis的采样</li><li>PS是离散的，和momentum basis(MS)的关系为：基系数互为DST-1变换(type-1 discrete sine transform)</li><li>有一些算符用MS展开简单，另一些用PS展开简单，例如动能算符用MS展开简单，势能算符用PS展开简单。求得一种展开，另一种展开通过DST-1变换就行了。</li></ul><h2 id="2-视觉知识"><a href="#2-视觉知识" class="headerlink" title="2 视觉知识"></a>2 视觉知识</h2><ul><li>MB的归一正交性验证</li></ul><p><img src="https://s2.loli.net/2024/07/28/X2Pc3BZMUw4mohe.png" alt=""></p><ul><li>MB的完备性验证</li></ul><p><img src="https://s2.loli.net/2024/07/28/opAHTkgm5Q694Nl.gif" alt=""></p><ul><li>PB在Dirac Basis中的展开系数</li></ul><p><img src="https://s2.loli.net/2024/07/28/XMpgNf9iU1YqwHz.gif" alt=""></p><ul><li>$\hat{\mathcal{x}}$在MB展开</li></ul><p><img src="https://s2.loli.net/2024/07/28/rOIfuNoX6vKd2Qx.png" alt=""></p><ul><li>$\hat{\mathcal{x}}$在PB展开</li></ul><p><img src="https://s2.loli.net/2024/07/28/LvRpePJoAmKzCiH.png" alt=""> </p><ul><li>$\hat{\mathcal{T}}$在MB展开</li></ul><p><img src="https://s2.loli.net/2024/07/28/McX5g7bmaxYnKGr.png" alt=""></p><ul><li>$\hat{\mathcal{T}}$在PB展开</li></ul><p><img src="https://s2.loli.net/2024/07/28/2NG6qnwhYiFUvP1.png" alt=""></p><ul><li>$\hat{\mathcal{P}}$在MB展开，可以发现只有虚部</li></ul><p><img src="https://s2.loli.net/2024/07/28/yUav1CXTif6bsRq.png" alt=""></p><ul><li>$\hat{\mathcal{P}}$在PB展开，可以发现只有虚部</li></ul><p><img src="https://s2.loli.net/2024/07/28/1Qr4ztxgvTuUXL3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathematica, quantum mechanics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Using Mathematica for QM  QM： states and operators</title>
      <link href="/2024/07/24/using-mathematica-for-qm-qm-states-and-operators/"/>
      <url>/2024/07/24/using-mathematica-for-qm-qm-states-and-operators/</url>
      
        <content type="html"><![CDATA[<h2 id="0-动机"><a href="#0-动机" class="headerlink" title="0 动机"></a>0 动机</h2><p>这是我的第一篇博客，没有获奖感言，锻炼下markdown使用以及测试下hexo-renderer-kramed渲染器的稳定性倒是有必要的。</p><hr><p><em>‘The limits of my language mean the limits of my world.’</em> —— Ludwig Wittgenstein</p><p>量子力学数学语言和代码语言之间的关系是什么？</p><h2 id="1-基矢的表示"><a href="#1-基矢的表示" class="headerlink" title="1 基矢的表示"></a>1 基矢的表示</h2><h3 id="1-1-算符和量子态的计算机语言"><a href="#1-1-算符和量子态的计算机语言" class="headerlink" title="1.1 算符和量子态的计算机语言"></a>1.1 算符和量子态的计算机语言</h3><script type="math/tex; mode=display">\hat{\mathcal{A}}=\sum_{ij}A_{ij} |i\rangle\langle j|,</script><script type="math/tex; mode=display">|\psi\rangle=\sum_i\psi_i|i\rangle,</script><h3 id="1-2-有限空间的处理方法"><a href="#1-2-有限空间的处理方法" class="headerlink" title="1.2 有限空间的处理方法"></a>1.2 有限空间的处理方法</h3><script type="math/tex; mode=display">\hat{\mathcal{A}}=\mathbb{1} \cdot \hat{\mathcal{A}} \cdot \mathbb{1}=(\hat{P}+\hat{Q}) \cdot \hat{\mathcal{A}} \cdot(\hat{P}+\hat{Q})=\hat{P} \cdot \hat{\mathcal{A}} \cdot \hat{P}+\hat{P} \cdot \hat{\mathcal{A}} \cdot \hat{Q}+\hat{Q} \cdot \hat{\mathcal{A}} \cdot \hat{P}+\hat{Q} \cdot \hat{\mathcal{A}} \cdot \hat{Q} \\= \underbrace{\sum_{i j} A_{i j}|i\rangle\langle j|}_{\text {within described subspace }}+\underbrace{\hat{P} \cdot \hat{\mathcal{A}} \cdot \hat{Q}+\hat{Q} \cdot \hat{\mathcal{A}} \cdot \hat{P}}_{\text {neglected coupling to (high-energy) part }}+\underbrace{\hat{Q} \cdot \hat{\mathcal{A}} \cdot \hat{Q}}_{\text {neglected (high-energy) part }},</script><script type="math/tex; mode=display">|\psi\rangle=1\cdot|\psi\rangle=(\hat{P}+\hat{Q})\cdot|\psi\rangle=\underbrace{\sum_i\psi_i |i\rangle}_{\text{within described subspace}}+\underbrace{\hat{Q}|\psi\rangle}_{\text{neglected (high-energy) part}}.</script><h2 id="2-时不变薛定谔方程"><a href="#2-时不变薛定谔方程" class="headerlink" title="2 时不变薛定谔方程"></a>2 时不变薛定谔方程</h2><p>数学语言为：</p><script type="math/tex; mode=display">\hat{\mathcal{H}}|\psi\rangle=E|\psi\rangle,</script><p><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\sum_jH_{mj}\psi_j=E\psi_m,</script><p>其向量形式为$H\cdot\vec{\psi}=E\vec{\boldsymbol{\psi}}$.</p><h2 id="3-时变薛定谔方程"><a href="#3-时变薛定谔方程" class="headerlink" title="3 时变薛定谔方程"></a>3 时变薛定谔方程</h2><p>数学语言为：</p><script type="math/tex; mode=display">\mathrm{i}\hbar\frac{\mathrm{d}}{\mathrm{d}t}|\psi(t)\rangle=\hat{\mathcal{H}}(t)|\psi(t)\rangle,</script><p>解方程得到：<br>$|\psi(t)\rangle=\hat{\mathcal{U}}(t_0;t)|\psi(t_0)\rangle$, 其中$\hat{\mathcal{U}}(t_0;t)$为传播子，对其用Magnus expansion得到$\hat{\mathcal{U}}(t_0;t)=\exp\left[\sum_{k=1}^\infty\hat{\Omega}_k(t_0;t)\right]$.</p><h3 id="3-1-假设基矢时不变，去解方程"><a href="#3-1-假设基矢时不变，去解方程" class="headerlink" title="3.1 假设基矢时不变，去解方程"></a>3.1 假设基矢时不变，去解方程</h3><p>假设$\hat{\mathcal{H}}(t)=\sum_{ij}H_{ij}(t) |i\rangle\langle j|$, $|\psi(t)\rangle=\sum\psi_i(t)\mid i\rangle$, 带入时变薛定谔方程，可以得到<br><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\mathrm{i}\hbar\dot{\psi}_m(t)=\sum_kH_{mk}(t)\psi_k(t),</script><p>其向量形式为$\mathrm{i}\hbar\dot{\vec{\boldsymbol{\psi}}}(t)=H(t)\cdot\vec{\boldsymbol{\psi}}(t)$.</p><h3 id="3-2-假设基矢时变，去解方程（用于相互作用图景）"><a href="#3-2-假设基矢时变，去解方程（用于相互作用图景）" class="headerlink" title="3.2 假设基矢时变，去解方程（用于相互作用图景）"></a>3.2 假设基矢时变，去解方程（用于相互作用图景）</h3><p>相互作用下哈密顿量为：$\hat{\mathcal{H}}(t)=\hat{\mathcal{H}}_0+\hat{\mathcal{H}}_1(t)$. 假设$\hat{\mathcal{H}}_0$可以对角化，即$\hat{\mathcal{H}}_0|i\rangle=E_i|i\rangle$, 则时变基矢表达式为：$|i(t)\rangle=e^{-\mathrm{i}E_it/\hbar}|i\rangle$, 于是可以将量子态用时变基展开：</p><script type="math/tex; mode=display">|\psi(t)\rangle=\sum_i\psi_i(t)\mid i(t)\rangle=\sum_i\psi_i(t)e^{-\mathrm{i}E_it/\hbar}|i\rangle,</script><p>将之带入时变薛定谔方程，可以得到<br><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\mathrm{i}\hbar\dot{\psi}_k(t)=\sum_j\psi_j(t)e^{-\mathrm{i}(E_j-E_k)t/\hbar}\langle k|\hat{\mathcal{H}}_1(t)|j\rangle=\sum_j\psi_j(t)e^{-\mathrm{i}(E_j-E_k)t/\hbar}{\mathcal{H}}_{1_{kj}}(t).</script><h3 id="3-3-特殊情况：-left-hat-mathcal-H-t-hat-mathcal-H-t’-right-0-forall-t-t’"><a href="#3-3-特殊情况：-left-hat-mathcal-H-t-hat-mathcal-H-t’-right-0-forall-t-t’" class="headerlink" title="3.3 特殊情况： $\left[\hat{\mathcal{H}}(t),\hat{\mathcal{H}}(t’)\right]=0 \forall(t,t’)$"></a>3.3 特殊情况： $\left[\hat{\mathcal{H}}(t),\hat{\mathcal{H}}(t’)\right]=0 \forall(t,t’)$</h3><p>可以直接解出薛定谔方程，其<br><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\vec{\boldsymbol{\psi}}(t)=\exp\left[-\frac{\mathrm{i}}{\hbar}\int_{t_0}^t\boldsymbol{H}(s)\mathrm{d}s\right]\cdot\vec{\boldsymbol{\psi}}(t_0).</script><h3 id="3-4-特殊情况：-哈密顿量是时不变的"><a href="#3-4-特殊情况：-哈密顿量是时不变的" class="headerlink" title="3.4 特殊情况： 哈密顿量是时不变的"></a>3.4 特殊情况： 哈密顿量是时不变的</h3><p>可以直接解出薛定谔方程，其<br><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\vec{\boldsymbol{\psi}}(t)=\exp\left[-\frac{\mathrm{i}(t-t_0)}\hbar\boldsymbol{H}\right]\cdot\vec{\boldsymbol{\psi}}(t_0).</script><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">phi:= = Flatten[KroneckerProduct[ phi1, phi2, phi3]]</code></pre><h2 id="4-基矢的计算机构造"><a href="#4-基矢的计算机构造" class="headerlink" title="4 基矢的计算机构造"></a>4 基矢的计算机构造</h2><h3 id="4-1-多维系统的描述"><a href="#4-1-多维系统的描述" class="headerlink" title="4.1 多维系统的描述"></a>4.1 多维系统的描述</h3><p>多维量子态的数学描述如下：</p><script type="math/tex; mode=display">\begin{aligned}|\psi\rangle=\left[\sum_{i_1=1}^{n_1}\psi_{i_1}^{(1)}|i_1\rangle^{(1)}\right]\otimes\left[\sum_{i_2=1}^{n_2}\psi_{i_2}^{(2)}|i_2\rangle^{(2)}\right]\otimes\cdots\otimes\left[\sum_{i_N=1}^{n_N}\psi_{i_N}^{(N)}|i_N\rangle^{(N)}\right]\\&\\=\sum_{i_1=1}^{n_1}\sum_{i_2=1}^{n_2}\cdots\sum_{i_N=1}^{n_N}\left[\psi_{i_1}^{(1)}\psi_{i_2}^{(2)}\ldots\psi_{i_N}^{(N)}\right]|i_1,i_2,\ldots,i_N\rangle\end{aligned},</script><p><strong>计算机语言</strong>为：<br></p><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">U[∆t_?NumericQ] := MatrixExp[-I*H*N[∆t]/~]</code></pre><br>多维算符的数学描述如下：<p></p><script type="math/tex; mode=display">\begin{aligned}\hat{A}=\left[\sum_{i_{1}=1}^{n_{1}}\sum_{j_{1}=1}^{n_{1}}a_{i_{1},j_{1}}^{(1)}|i_{1}\rangle^{(1)}\langle j_{1}|^{(1)}\right]\otimes\left[\sum_{i_{2}=1}^{n_{2}}\sum_{j_{2}=1}^{n_{2}}a_{i_{2},j_{2}}^{(2)}|i_{2}\rangle^{(2)}\langle j_{2}|^{(2)}\right]\otimes\cdots\otimes\left[\sum_{i_{N}=1}^{n_{N}}\sum_{i_{N}=1}^{n_{N}}a_{i_{N},j_{N}}^{(N)}|i_{N}\rangle^{(N)}\langle j_{N}|^{(N)}\right]\\&\\=\sum_{i_{1}=1}^{n_{1}}\sum_{j_{1}=1}^{n_{1}}\sum_{i_{2}=1}^{n_{2}}\sum_{j_{2}=1}^{n_{2}}\cdots\sum_{i_{N}=1}^{n_{N}}\sum_{j_{N}=1}^{n_{N}}\left[a_{i_{1}j_{1}}^{(1)}a_{i_{2}j_{2}}^{(2)}\cdots a_{i_{N}j_{N}}^{(N)}\right]|i_{1},i_{2},\ldots,i_{N}\rangle\langle j_{1},j_{2},\ldots,j_{N}|.\end{aligned}</script><p><strong>计算机语言</strong>为：<br></p><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">A = KroneckerProduct[a1, a2, a3]</code></pre><br>我们经常考察作用在某一成员空间的算符，这种算符的<br><strong>计算机语言</strong>（假设为三体系统）为<br><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">H1 = KroneckerProduct[h1,                    IdentityMatrix[Dimensions[h2]],                    IdentityMatrix[Dimensions[h3]]];H2 = KroneckerProduct[IdentityMatrix[Dimensions[h1]],                    h2,                    IdentityMatrix[Dimensions[h3]]];H3 = KroneckerProduct[IdentityMatrix[Dimensions[h1]],                    IdentityMatrix[Dimensions[h2]],                    h3];</code></pre><p></p><h3 id="4-2-偏迹的描述"><a href="#4-2-偏迹的描述" class="headerlink" title="4.2 偏迹的描述"></a>4.2 偏迹的描述</h3><p>数学描述如下，假如有一个三体系统：</p><script type="math/tex; mode=display">\hat{\rho}_{\mathrm{ABC}}=\sum_{i,i^{\prime}=1}^{d_{\mathrm{A}}}\sum_{j,j^{\prime}=1}^{d_{\mathrm{B}}}\sum_{k,k^{\prime}=1}^{d_{\mathrm{C}}}\rho_{i,j,k,i^{\prime},j^{\prime},k^{\prime}}|i_{\mathrm{A}},j_{\mathrm{B}},k_{\mathrm{C}}\rangle\langle i_{\mathrm{A}}^{\prime},j_{\mathrm{B}}^{\prime},k_{\mathrm{C}}^{\prime}|,</script><p>其中$\rho$是个6维张量。对B求偏迹的数学公式为：</p><script type="math/tex; mode=display">\begin{gathered}\hat{\rho}_{\mathrm{AC}}=\sum_{j^{\prime\prime}=1}^{d_{\mathrm{B}}}\langle j_{\mathrm{B}}^{\prime\prime}|\hat{\rho}_{\mathrm{ABC}}|j_{\mathrm{B}}^{\prime\prime}\rangle\\=\sum_{j^{\prime\prime}=1}^{d_{\mathrm{B}}}\langle j_{\mathrm{B}}^{\prime\prime}|\left\lfloor\sum_{i,i^{\prime}=1}^{d_{\mathrm{A}}}\sum_{j,j^{\prime}=1}^{d_{\mathrm{B}}}\sum_{k,k^{\prime}=1}^{d_{\mathrm{C}}}\rho_{i,j,k,i^{\prime},j^{\prime},k^{\prime}}|i_{\mathrm{A}},j_{\mathrm{B}},k_{\mathrm{C}}\rangle\langle i_{\mathrm{A}}^{\prime},j_{\mathrm{B}}^{\prime},k_{\mathrm{C}}^{\prime}|\right\rfloor|j_{\mathrm{B}}^{\prime\prime}\rangle \\=\sum_{j^{\prime\prime}=1}^{d_{B}}\sum_{i,i^{\prime}=1}^{d_{A}}\sum_{j,j=1}^{d_{B}}\sum_{k,k^{\prime}=1}^{d_{C}}\rho_{i,j,k,i^{\prime},j^{\prime},k^{\prime}}\langle j_{B}^{\prime\prime}|i_{A},j_{B},k_{C}\rangle\langle i_{A}^{\prime},j_{B}^{\prime},k_{C}^{\prime}|j_{B}^{\prime\prime}\rangle\\=\sum_{j^{\prime\prime}=1}^{d_{B}}\sum_{i,i^{\prime}=1}^{d_{A}}\sum_{j,j^{\prime}=1}^{d_{B}}\sum_{k,k^{\prime}=1}^{d_{C}}\rho_{i,j,k,i^{\prime},j^{\prime},k^{\prime}}[\delta_{j^{\prime\prime},j}|i_{A},k_{C}\rangle]\left[\delta_{j^{\prime\prime},j^{\prime}}\langle i_{A}^{\prime},k_{C}^{\prime}\right|] \\=\sum_{i,i^{\prime}=1}^{d_{A}}\sum_{k,k^{\prime}=1}^{d_{C}}\left[\sum_{j=1}^{d_{B}}\rho_{i,j,k,i^{\prime},j,k^{\prime}}\right]|i_{A},k_{C}\rangle\langle i_{A}^{\prime},k_{C}^{\prime}|,\end{gathered}</script><p>可见这是对6维张量在2&amp;5维上的压缩操作。<br>所以用<strong>计算机语言</strong>去表示偏迹，可以先把$\hat{\rho}_{\mathrm{ABC}}$重塑成6维张量：<br></p><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">R = ArrayReshape[ρABC, {dA,dB,dC,dA,dB,dC}]</code></pre><br>然后在2&amp;5维上进行压缩操作：<br><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">S = TensorContract[R, {2,5}]</code></pre><br>最后再还原成密度矩阵形式(2维张量)：<br><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">ρAC = Flatten[S, {{1,2}, {3,4}}]</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathematica, quantum mechanics </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
