<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>河边</title>
      <link href="/2024/08/26/he-bian/"/>
      <url>/2024/08/26/he-bian/</url>
      
        <content type="html"><![CDATA[<h2 id="20240825"><a href="#20240825" class="headerlink" title="20240825"></a>20240825</h2><p><img src="https://s2.loli.net/2024/08/26/XuwYdfnb6DmsORz.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/5lAO4YUviqGXSrx.jpg" alt=""></p><h2 id="20220628"><a href="#20220628" class="headerlink" title="20220628"></a>20220628</h2><p><img src="https://s2.loli.net/2024/08/26/Pz5SC7qoawYky9r.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/2ZtopRHqO6zsAEl.jpg" alt=""></p><h2 id="20210831"><a href="#20210831" class="headerlink" title="20210831"></a>20210831</h2><p><img src="https://s2.loli.net/2024/08/26/3XkPQ1N65DMVAEH.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/azZHe3huqfpQBvw.jpg" alt=""></p><h2 id="20200822"><a href="#20200822" class="headerlink" title="20200822"></a>20200822</h2><p><img src="https://s2.loli.net/2024/08/26/lMzjiGQ4VrdqPgb.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/ypNm3YCHLirS7UW.jpg" alt=""></p><h2 id="20190821"><a href="#20190821" class="headerlink" title="20190821"></a>20190821</h2><p><img src="https://s2.loli.net/2024/08/26/8nqRFcKMtCYy56X.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/m5FYEHWNLIi6wMq.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary, landscape </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thorlabs PAX1000不准直会发生的现象及原因探寻</title>
      <link href="/2024/08/21/thorlabs-pax1000-bu-zhun-zhi-hui-fa-sheng-de-xian-xiang-ji-yuan-yin-tan-xun/"/>
      <url>/2024/08/21/thorlabs-pax1000-bu-zhun-zhi-hui-fa-sheng-de-xian-xiang-ji-yuan-yin-tan-xun/</url>
      
        <content type="html"><![CDATA[<h2 id="0-现象"><a href="#0-现象" class="headerlink" title="0 现象"></a>0 现象</h2><ol><li><p>前几天使用matlab visa库控制PAX1000测试光芯片偏振调制时，发现偏振输出会在邦加球上两条调制曲线之间无规律横跳：<br><img src="https://s2.loli.net/2024/08/21/WomscDVfxU8qrlH.png" alt=""><br>固定某个调制电压，发现偏振态会在两个邦加球两点之间无规律横跳。</p></li><li><p>为了排除光芯片的原因，我直接向PAX1000打入单模耦合输入的偏振光（正确做法是拿保偏接，但是单模短时间内偏振变化不会太大），记录120s内visa以1Hz速率传输的数据和120s中某一时刻PAX1000自带软件的截图，可以发现：</p></li></ol><ul><li>使用matlab visa库读取的方位角(Azimuth θ)、椭圆率角(Ellipticity η)会横跳；</li><li>使用PAX1000自带软件测试不会横跳；</li><li>PAX1000自带软件数据在横跳数据之间，但不是正中间。</li></ul><p><img src="https://s2.loli.net/2024/08/21/ROHPFrzL8yIShW4.jpg" alt="visa传输数据"><br><img src="https://s2.loli.net/2024/08/21/MrA7OFbKNexI5LE.png" alt="PAX1000软件数据"></p><h2 id="1-朔源"><a href="#1-朔源" class="headerlink" title="1 朔源"></a>1 朔源</h2><p>查阅手册发现原因可能是前些天准直器松动后我重新固定了，但是没有准直。而没有准直会出现以下问题，即引入奇数次谐波：<br><em>“The angular alignment is critical for another reason: As explained in the section Rotating Waveplate Technique , the photo current is analyzed by a Fast Fourier Transformation and ideally<br>consists only of even-numbered components (harmonics). If the beam hits the waveplate not<br>exactly perpendicular, unwanted odd-numbered harmonics will appear in the photo current. The<br>same happens, if the incident beam consists reflected from the inner surface of the hollow shaft<br>light components. These unwanted components have a significant impact on the measurement<br>accuracy. The Alignment Assistance tool can be used to align the beam, which will minimize<br>the contribution from unwanted components.”</em></p><p>于是我手动准直了一下PAX1000，发现数据反复横跳的现象确实消失了，且visa读出数据与软件数据完全吻合。然而，为什么不准直会引入奇数次谐振？为了解释这个问题，我们首先要知道PAX1000的工作原理。<br><img src="https://s2.loli.net/2024/08/21/ALkfWGJZsV4NHmo.png" alt="FOURIER ANALYSIS USING A ROTATING QUARTER-WAVE RETARDER"><br>由于PAX1000使用了上世纪的旋转波片技术，所以随便翻一本经典的偏振书籍就能找到解释：不同的偏振光经过旋转1/4波片及固定极化片，再经过光电探测可以得到随时间变化的光电流</p><script type="math/tex; mode=display">I(\theta)=\frac{1}{2}\left[\left(S_{0}+\frac{S_{1}}{2}\right)+\frac{S_{1}}{2}\cos4\theta+\frac{S_{2}}{2}\sin4\theta-S_{3}\sin2\theta\right]\\=\frac{1}{2}[A-B\sin2\omega t+C\cos4\omega t+D\sin4\omega t]</script><p>这是傅里叶展开，于是可以通过积分算系数，再解方程求偏振参数：</p><script type="math/tex; mode=display">\begin{aligned}&A=\frac1\pi\int_0^{2\pi}I(\theta) d\theta\\&B=\frac2\pi\int_0^{2\pi}I(\theta)\sin2\theta d\theta\\&C=\frac2\pi\int_0^{2\pi}I(\theta)\cos4\theta d\theta\\&D=\frac2\pi\int_0^{2\pi}I(\theta)\sin4\theta d\theta\end{aligned}</script><p>由于现实中没有积分器，于是采样并求和，就得到了PAX1000的数据处理方法：</p><script type="math/tex; mode=display">\begin{aligned}A & =\frac{2}{N} \sum_{n=1}^{N} I\left(n \theta_{j}\right) \\B & =\frac{4}{N} \sum_{n=1}^{N} I\left(n \theta_{j}\right) \sin 2 n \theta_{j} \\C & =\frac{4}{N} \sum_{n=1}^{N} I\left(n \theta_{j}\right) \cos 4 n \theta_{j} \\D & =\frac{4}{N} \sum_{n=1}^{N} I\left(n \theta_{j}\right) \sin 4 n \theta_{j}\end{aligned}</script><p>这个表达式里面确实只有偶数项，那奇数项会从哪里引入呢？另外，为什么只在两个值之间横跳？再仔细翻阅手册，可以发现这么一段话：<br><em>“The photo current measured during this half turn is analyzed by a Fast Fourier Transformation (FFT). By default, the FFT “splits” the data into 512 measurement points (ADC values).”</em><br>好家伙，难道用visa时我只用了半圈去计算？于是我试了下将软件调成以半圈为周期计算，结果还真是反复横跳，且相当规律：<br><img src="https://s2.loli.net/2024/08/21/Mgs3olvm2ZYaUiz.png" alt=""><br>这样一来，我们要解决的问题就变成了：<br><strong>当没准直时，且使用半圈去计算时，为什么偏振结果会跳变？</strong></p><h2 id="2-原因"><a href="#2-原因" class="headerlink" title="2 原因"></a>2 原因</h2><p>当没有准直时，光线即使斜入射波片，也不会造成前半圈和后半圈结果不同，所以不对称很可能来源于波片瑕疵。然而，假如确实是由波片不完美导致的，由于旋转过程中光束落点处波片厚度不同，那么准直入射的情况也应该显现出偏振跳变。实际情况是，只有未准直的光束显现出了偏振跳变，所以肯定不是由于波片瑕疵导致的。</p><p>在查阅文献后，我找到了可能的问题来源：实际情况中，波片平面与其旋转轴肯定不是完美垂直，而是存在一个角度”Wobble”，而当波片高速转动时，由于离心力这个角度放大。<br><img src="https://s2.loli.net/2024/08/24/TELMOl4NrndsxGf.png" alt=""></p><p>为了说明”Wobble”可能导致偏振跳变的情况，我们分别考察准直和不准直的两种情况：</p><ol><li><p>准直时，在波片旋转的过程中，入射光线和主轴的夹角不会发生任何改变。这里用mathematica做了一个动画演示，其中蓝色向量代表入射光线，灰色圆盘代表波片，绿线代表波片主轴，红色向量代表波片法向，设置”Wobble”=30°。另外，我画出了旋转过程中入射光线和主轴的夹角。可以发现，在波片旋转过程中夹角不发生任何改变：<br><img src="https://s2.loli.net/2024/08/24/Krf4chJQsN5eZyC.gif" alt=""><br><img src="https://s2.loli.net/2024/08/24/naWjO94UV7oFbAu.jpg" alt=""><br>另外，稍微想一下也会发现光束落点也不会影响半圈一致性。</p></li><li><p>不准直时，入射光线和主轴的夹角发现改变，<strong>且有99.9999…%的可能性使半圈对称性“破缺”</strong>。这里同样做了动画演示，配置同上，入射光线偏斜45°。可以发现，在波片旋转中入射光线和主轴的夹角一直在变化，且前半圈和后半圈不具有对称性：<br><img src="https://s2.loli.net/2024/08/24/gF76ZanpXhoWCPN.gif" alt=""><br><img src="https://s2.loli.net/2024/08/24/euv4PGfCcyLYMjI.jpg" alt=""></p></li></ol><p><strong>然而有一种特殊情况不会导致对称性“破缺”</strong>，这种情况几乎不可能发生，这种情况下主轴在旋转时不会于准直入射方向发生夹角的改变，因此等价于光束斜入射”Wobble”=0°的波片。<br><img src="https://s2.loli.net/2024/08/24/o89mFNbqZuvjrQy.gif" alt=""><br><img src="https://s2.loli.net/2024/08/24/zUNAyhmxWaFwSG5.jpg" alt=""></p><h2 id="3-闭环"><a href="#3-闭环" class="headerlink" title="3 闭环"></a>3 闭环</h2><ol><li>没准值时visa偏振跳变是由于没有下发整数圈数据处理的指令。</li><li>准直时用半圈处理数据不会导致偏振跳变。</li><li>理想/非理想情况下(当不存在/存在wobble时)，准直且用用半圈处理数据不会导致偏振跳变。</li><li>理想情况下(当不存在wobble时)，没准直且用用半圈处理数据不会导致偏振跳变。</li><li>非理想情况下(当存在wobble时)，没准直且用用半圈处理数据会导致偏振跳变。</li><li><strong>手册中不准值时引入奇数项的具体含义是：光强中不仅有二次项（半圈）以及四次项（1/4圈）存在了，还引入了一次项（1圈）</strong>。</li></ol><h2 id="参考文献及代码链接"><a href="#参考文献及代码链接" class="headerlink" title="参考文献及代码链接"></a>参考文献及代码链接</h2><ol><li>Williams P A. Rotating-wave-plate Stokes polarimeter for differential group delay measurements of polarization-mode dispersion[J]. Applied optics, 1999, 38(31): 6508-6515.</li><li><a href="https://www.wolframcloud.com/obj/wya1759991046/Published/pax1000simu.nb">mathematica笔记本链接</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> apparatus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apparatus, polarization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>叠层阻抗表</title>
      <link href="/2024/07/30/die-ceng-zu-kang/"/>
      <url>/2024/07/30/die-ceng-zu-kang/</url>
      
        <content type="html"><![CDATA[<p>这是一张14层的叠层阻抗表，黄色标注了1-4层的三阶盲埋：<br><img src="https://s2.loli.net/2024/07/30/D9UOSApXMT4EBdj.png" alt=""><br>与阻抗计算工具的结果吻合：<br><img src="https://s2.loli.net/2024/07/30/JCwgvN4IMdceSlb.png" alt=""><br><img src="https://s2.loli.net/2024/07/30/xoYAMfbRiZKE2pu.png" alt=""><br>参考：<br><a href="https://zhuanlan.zhihu.com/p/512495251">PCB板材的基础知识</a><br><a href="https://baijiahao.baidu.com/s?id=1787683941435650876&amp;wfr=spider&amp;for=pc">高速PCB的铜箔选用指南</a><br><a href="https://www.sunshinepcb.com/news/knowledge/81.html">PCB叠层设计指南 | 从材料选型到叠构设计</a><br><a href="https://www.protoexpress.com/tools/pcb-impedance-calculator/">Impedance Calculator</a><br>附12层叠层阻抗表：<br><img src="https://s2.loli.net/2024/08/19/ShYKyzBtGqRonud.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> electronic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electronic, PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project · JZ 存储器备忘录</title>
      <link href="/2024/07/29/project-jz-cun-chu-qi-bei-wang-lu/"/>
      <url>/2024/07/29/project-jz-cun-chu-qi-bei-wang-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="0-动机"><a href="#0-动机" class="headerlink" title="0 动机"></a>0 动机</h2><p>Datasheet太多了，点开文件夹查找过于麻烦。作为记性不好又懒得一匹的包工头，不需要动脑写逻辑，只需要了解关键内容。因此摘录sheet要点并加上芯片架构层面的内容和思考，不包含时序和芯片自带功能（例如NAND、MRAM的ECC）的解读，作为一个快捷的备忘录。</p><h2 id="1-DDR2"><a href="#1-DDR2" class="headerlink" title="1 DDR2"></a>1 DDR2</h2><ul><li><p>型号：ISSI(芯成 · 美) IS43DR16128C<br>容量：2Gb = 128M$\times$16b = 8(banks)$\times$16M$\times$16b；<br>位宽：16b<br><img src="https://s2.loli.net/2024/07/29/VRjSW17Zmr9sGYg.png" alt=""><br>速率等ORDER INFO：<br><img src="https://s2.loli.net/2024/07/29/HA2tI3F4SPLQrNz.png" alt=""></p></li><li><p>特征参数<br><img src="https://s2.loli.net/2024/07/29/8ynSs1dVxYEO2jW.png" alt=""></p></li><li><p>架构<br><img src="https://s2.loli.net/2024/07/29/Jh42Vz1vXlWRQOr.png" alt=""></p></li><li><p>管脚<br><img src="https://s2.loli.net/2024/07/29/tmMiAjwrGXa3obW.png" alt=""><br><img src="https://s2.loli.net/2024/07/29/ohdg3EtqW29fGaD.png" alt=""><br>管脚特征：<br>没有读使能信号，读使能是通过拉高写使能。<br>DDR2不像NAND FLASH一样复用IO可能是因为要求高速。<br>DM掩码某些数据位，而DQS有效化某些数据时刻，作用不一样。</p></li></ul><h2 id="2-NAND-FLASH"><a href="#2-NAND-FLASH" class="headerlink" title="2 NAND FLASH"></a>2 NAND FLASH</h2><ul><li><p>型号：MICRON(美光 · 美) MT29F128G08AMCABH2<br>容量：128Gb = 16384(块)$\times$128(页)$\times$8640B；<br>位宽：8b<br><img src="https://s2.loli.net/2024/07/29/xcMjmuVCUGFgHfk.png" alt=""></p></li><li><p>特征参数<br><img src="https://s2.loli.net/2024/07/29/ujJgxMwW1hY2RU7.png" alt=""><br>注意，NAND手册一般不会给出工作在同步模式下的时钟频率。</p></li><li><p>架构<br><img src="https://s2.loli.net/2024/07/29/8kyEAR1xzLZG6Ma.png" alt=""><br><img src="https://s2.loli.net/2024/07/29/lNm5boGgRK1fX6h.png" alt=""><br>MT29F128G08AMCABH2有4个LUN。</p></li><li><p>管脚<br><img src="https://s2.loli.net/2024/07/29/DoIMucBGz98Leth.png" alt=""><br>为什么这样分配管脚：<br><strong><em>比如命令锁存使能(Command Latch Enable,CLE)和地址锁存使能(Address Latch Enable，ALE)，那是因为，Nand Flash就8个I/O，而且是复用的，也就是，可以传数据，也可以传地址，也可以传命令，为了区分…</em></strong><br><strong><em>Nand flash支持一个叫做CE(chip enable) don’t-care的技术…由于某些外部应用的频率比较低，而Nand Flash内部操作速度比较快…节省功耗…</em></strong><br>参考：<a href="https://zhuanlan.zhihu.com/p/340496845">智能座舱之存储篇第三篇—-NAND Flash 一眼就看明白了</a></p></li><li><p>LUN寻址规则<br><img src="https://s2.loli.net/2024/07/29/Fs5zOQhwPALX26W.png" alt=""></p></li></ul><h2 id="3-QSPI-FLASH"><a href="#3-QSPI-FLASH" class="headerlink" title="3 QSPI FLASH"></a>3 QSPI FLASH</h2><ul><li><p>型号：Infineon(原厂Cypress，2019年被Infineon收购 · 美) S25FL128S<br>容量：128Mb<br>位宽：4b<br><img src="https://s2.loli.net/2024/07/30/M1EioZbzukJIBsL.png" alt=""><br><strong>EHPLC（Enhanced High-Performance Low Command Mode）增强型高性能低命令模式</strong>：<br>功能：EHPLC 模式专注于在最低的命令开销下提供最高的数据传输速率。通过优化命令和数据传输过程，EHPLC 模式能够实现更高的性能，特别是在需要快速读取大量数据的应用中。<br>特点：EHPLC 模式可能会使用更高效的命令集和协议来减少延迟和增加吞吐量，从而提供比传统模式更高的性能。<br><strong>HPLC（High-Performance Low Command Mode）高性能低命令模式</strong>：<br>功能：HPLC 模式也致力于提高数据传输速率，但与 EHPLC 相比，其优化程度可能稍低。HPLC 仍然通过减少命令开销和提高数据传输效率来提供良好的性能。<br>特点：HPLC 模式通常在标准 QSPI 操作的基础上进行一些优化，使其适用于大多数高性能应用，但可能不如 EHPLC 那样极致优化。</p></li><li><p>特征参数<br>注意，这个手册block块=sector扇区<br><img src="https://s2.loli.net/2024/07/30/gMQRPDeht2Ak146.png" alt=""></p></li><li><p>架构<br><img src="https://s2.loli.net/2024/07/30/3FP1fSiHJnlteUG.png" alt=""><br>非常草率的架构图。。。<br><img src="https://s2.loli.net/2024/07/30/OARVLNiy12acW4g.png" alt=""></p></li><li><p>管脚<br><img src="https://s2.loli.net/2024/07/30/M5eVJZ9mFQrfE8z.png" alt=""><br>类似于NAND，QUAD模式4个IO复用指令、地址、数据，并且时分传递。</p></li></ul><h2 id="4-MRAM"><a href="#4-MRAM" class="headerlink" title="4 MRAM"></a>4 MRAM</h2><ul><li><p>型号：EVERSPIN(埃弗斯平 · 美，只做MRAM的小公司，从随意的中文名就可以看出) MR5A16ACYS35<br>容量：32Mb；位宽：16b<br><img src="https://s2.loli.net/2024/07/29/kbTa9m7tzepWUBv.png" alt=""></p></li><li><p>特征参数<br><img src="https://s2.loli.net/2024/07/29/oVRBMi3vUqcyWJe.png" alt=""></p></li><li><p>架构<br><img src="https://s2.loli.net/2024/07/29/tOnjAXr8vdWDmVx.png" alt=""><br>架构图非常简单清晰。<br>“sense amps”（感应放大器）是用来检测和放大存储单元中的信号电压的电路。这些感应放大器的作用是读取MRAM单元的状态，即确定存储单元中存储的是0还是1。具体来说，MRAM的存储单元通过磁性材料的磁化方向来表示数据，而感应放大器则通过检测这些磁化方向造成的电压变化来读取数据。</p></li><li><p>管脚<br><img src="https://s2.loli.net/2024/07/29/TRfj4amweL7qxQg.png" alt=""><br>Output Enable和Write Enable相当于外部输入的读写使能信号。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> electronic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electronic, memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DJI mini4K拍照模式测试</title>
      <link href="/2024/07/28/dji-mini4k-pai-zhao-mo-shi-ce-shi/"/>
      <url>/2024/07/28/dji-mini4k-pai-zhao-mo-shi-ce-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>主要是天气不错，但是出去骑车又很热，于是闲着没事玩玩mini4K几种照相模式，而且台风格美过境后风力不错，目测偶尔有六级以上，所以作死测试一下其抗风能力。</p><ul><li>全景</li></ul><p>使用这个7年前就断更的开源插件hexo-tag-panoview：<br></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">$ npm install hexo<span class="token operator">-</span>tag<span class="token operator">-</span>panoview <span class="token operator">--</span>save</code></pre><p></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">{</span><span class="token operator">%</span> panoview <span class="token string">"https://s2.loli.net/2024/07/28/QkJsBRyWpc3ECH8.jpg"</span> <span class="token number">400</span> <span class="token number">790</span> <span class="token operator">%</span><span class="token punctuation">}</span><span class="token comment">//400 是指全景的高度；</span><span class="token comment">//790 是指全景的宽度。</span><span class="token punctuation">{</span><span class="token operator">%</span> endpanoview <span class="token operator">%</span><span class="token punctuation">}</span></code></pre><p>得到图片：<br></p><div id="panoview8180" style="margin: 0 auto"></div><script src="https://unpkg.com/three@0.88.0/build/three.min.js"></script><script>    var camera, scene, renderer;    var isUserInteracting = false,        onMouseDownMouseX = 0, onMouseDownMouseY = 0,        lon = 0, onMouseDownLon = 0,        lat = 0, onMouseDownLat = 0,        phi = 0, theta = 0;    init();    animate();    function init() {        var container, mesh;        container = document.getElementById('panoview8180');        var width = container.style.width;        camera = new THREE.PerspectiveCamera(75, 2, 1, 1000);        camera.target = new THREE.Vector3(0, 0, 0);        scene = new THREE.Scene();        var geometry = new THREE.SphereBufferGeometry(500, 60, 40);        // invert the geometry on the x-axis so that all of the faces point inward        geometry.scale(- 1, 1, 1);        var material = new THREE.MeshBasicMaterial({            map: new THREE.TextureLoader().load('https://s2.loli.net/2024/07/28/QkJsBRyWpc3ECH8.jpg')        });        mesh = new THREE.Mesh(geometry, material);        scene.add(mesh);        renderer = new THREE.WebGLRenderer();        renderer.setPixelRatio(window.devicePixelRatio);        renderer.setSize(window.innerWidth, window.innerHeight);        renderer.domElement.style.width = "790px";        renderer.domElement.style.height = "400px";        container.appendChild(renderer.domElement);        container.addEventListener('mousedown', onDocumentMouseDown, false);        container.addEventListener('mousemove', onDocumentMouseMove, false);        container.addEventListener('mouseup', onDocumentMouseUp, false);        // container.addEventListener('wheel', onDocumentMouseWheel, false);        container.addEventListener('dragover', function (event) {            event.preventDefault();            event.dataTransfer.dropEffect = 'copy';        }, false);        container.addEventListener('dragenter', function (event) {            document.body.style.opacity = 0.5;        }, false);        container.addEventListener('dragleave', function (event) {            document.body.style.opacity = 1;        }, false);    }    function onDocumentMouseDown(event) {        event.preventDefault();        isUserInteracting = true;        onMouseDownMouseX = event.clientX;        onMouseDownMouseY = event.clientY;        onMouseDownLon = lon;        onMouseDownLat = lat;    }    function onDocumentMouseMove(event) {        if (isUserInteracting === true) {            lon = (onMouseDownMouseX - event.clientX) * 0.1 + onMouseDownLon;            lat = (event.clientY - onMouseDownMouseY) * 0.1 + onMouseDownLat;        }    }    function onDocumentMouseUp(event) {        isUserInteracting = false;    }    function onDocumentMouseWheel(event) {        var fov = camera.fov + event.deltaY * 0.05;        camera.fov = THREE.Math.clamp(fov, 10, 75);        camera.updateProjectionMatrix();        return false;    }    function animate() {        requestAnimationFrame(animate);        update();    }    function update() {        if (isUserInteracting === false) {            lon += 0.1;        }        lat = Math.max(- 85, Math.min(85, lat));        phi = THREE.Math.degToRad(90 - lat);        theta = THREE.Math.degToRad(lon);        camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);        camera.target.y = 500 * Math.cos(phi);        camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);        camera.lookAt(camera.target);        /*        // distortion        camera.position.copy( camera.target ).negate();        */        renderer.render(scene, camera);    }</script><p></p><p>对比无全景效果，效果居然还不错：<br><img src="https://s2.loli.net/2024/07/28/QkJsBRyWpc3ECH8.jpg" alt=""></p><ul><li>180°</li></ul><p><img src="https://s2.loli.net/2024/07/28/CbeE5f7PvIyTOxX.jpg" alt=""></p><ul><li>广角</li></ul><p><img src="https://s2.loli.net/2024/07/28/R72NqPUspjJzlEA.jpg" alt=""></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>mini4K 1/2.3’’小尺寸CMOS应对广角及以上照片的拍摄方法是分时定位拍摄算法合成</li><li>mini4K抗6级风问题不大</li></ul>]]></content>
      
      
      <categories>
          
          <category> drone </category>
          
      </categories>
      
      
        <tags>
            
            <tag> drone, mini4K </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Using Mathematica for QM  one particle in one dimension (1)</title>
      <link href="/2024/07/28/using-mathematica-for-qm-one-particle-in-one-dimension-1/"/>
      <url>/2024/07/28/using-mathematica-for-qm-one-particle-in-one-dimension-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0-动机"><a href="#0-动机" class="headerlink" title="0 动机"></a>0 动机</h2><p>追求静态网页支持在线mathematica是个错误的方向，直接将笔记上传至mathematica云端就行。但是mathematica的排版一直很难用，就算调用matex包，mathematica依然对latex语言支持很差劲。经过尝试，意外发现它对MathML脚本支持比较完善。另外，将枯燥的standardform转换为traditionalform可以将代码语言转换成公式语言，一定程度上能增加代码可读性。</p><p>然而，一些mathematica的动态或静态图片结果不会加载在云端，需要在云端运行或者下载到本地运行，这就比较麻烦。</p><p><strong>因此，主页放上要点和结论性的图片，同时附上mathematica笔记本链接，会是一个不错的结合。</strong></p><p><a href="https://www.wolframcloud.com/env/wya1759991046/Published/Use%20mathematica%20for%20QM%204.1.1_4.1.6.nb">mathematica笔记本链接</a></p><h2 id="1-要点"><a href="#1-要点" class="headerlink" title="1 要点"></a>1 要点</h2><ul><li>finite-resolution position basis(FRPS/PS)本质上是对Dirac basis的采样</li><li>PS是离散的，和momentum basis(MS)的关系为：基系数互为DST-1变换(type-1 discrete sine transform)</li><li>有一些算符用MS展开简单，另一些用PS展开简单，例如动能算符用MS展开简单，势能算符用PS展开简单。求得一种展开，另一种展开通过DST-1变换就行了。</li></ul><h2 id="2-视觉知识"><a href="#2-视觉知识" class="headerlink" title="2 视觉知识"></a>2 视觉知识</h2><ul><li>MB的归一正交性验证</li></ul><p><img src="https://s2.loli.net/2024/07/28/X2Pc3BZMUw4mohe.png" alt=""></p><ul><li>MB的完备性验证</li></ul><p><img src="https://s2.loli.net/2024/07/28/opAHTkgm5Q694Nl.gif" alt=""></p><ul><li>PB在Dirac Basis中的展开系数</li></ul><p><img src="https://s2.loli.net/2024/07/28/XMpgNf9iU1YqwHz.gif" alt=""></p><ul><li>$\hat{\mathcal{x}}$在MB展开</li></ul><p><img src="https://s2.loli.net/2024/07/28/rOIfuNoX6vKd2Qx.png" alt=""></p><ul><li>$\hat{\mathcal{x}}$在PB展开</li></ul><p><img src="https://s2.loli.net/2024/07/28/LvRpePJoAmKzCiH.png" alt=""> </p><ul><li>$\hat{\mathcal{T}}$在MB展开</li></ul><p><img src="https://s2.loli.net/2024/07/28/McX5g7bmaxYnKGr.png" alt=""></p><ul><li>$\hat{\mathcal{T}}$在PB展开</li></ul><p><img src="https://s2.loli.net/2024/07/28/2NG6qnwhYiFUvP1.png" alt=""></p><ul><li>$\hat{\mathcal{P}}$在MB展开，可以发现只有虚部</li></ul><p><img src="https://s2.loli.net/2024/07/28/yUav1CXTif6bsRq.png" alt=""></p><ul><li>$\hat{\mathcal{P}}$在PB展开，可以发现只有虚部</li></ul><p><img src="https://s2.loli.net/2024/07/28/1Qr4ztxgvTuUXL3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> mathematica </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathematica, quantum mechanics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Using Mathematica for QM  QM： states and operators</title>
      <link href="/2024/07/24/using-mathematica-for-qm-qm-states-and-operators/"/>
      <url>/2024/07/24/using-mathematica-for-qm-qm-states-and-operators/</url>
      
        <content type="html"><![CDATA[<h2 id="0-动机"><a href="#0-动机" class="headerlink" title="0 动机"></a>0 动机</h2><p>这是我的第一篇博客，没有获奖感言，锻炼下markdown使用以及测试下hexo-renderer-kramed渲染器的稳定性倒是有必要的。</p><hr><p><em>‘The limits of my language mean the limits of my world.’</em> —— Ludwig Wittgenstein</p><p>量子力学数学语言和代码语言之间的关系是什么？</p><h2 id="1-基矢的表示"><a href="#1-基矢的表示" class="headerlink" title="1 基矢的表示"></a>1 基矢的表示</h2><h3 id="1-1-算符和量子态的计算机语言"><a href="#1-1-算符和量子态的计算机语言" class="headerlink" title="1.1 算符和量子态的计算机语言"></a>1.1 算符和量子态的计算机语言</h3><script type="math/tex; mode=display">\hat{\mathcal{A}}=\sum_{ij}A_{ij} |i\rangle\langle j|,</script><script type="math/tex; mode=display">|\psi\rangle=\sum_i\psi_i|i\rangle,</script><h3 id="1-2-有限空间的处理方法"><a href="#1-2-有限空间的处理方法" class="headerlink" title="1.2 有限空间的处理方法"></a>1.2 有限空间的处理方法</h3><script type="math/tex; mode=display">\hat{\mathcal{A}}=\mathbb{1} \cdot \hat{\mathcal{A}} \cdot \mathbb{1}=(\hat{P}+\hat{Q}) \cdot \hat{\mathcal{A}} \cdot(\hat{P}+\hat{Q})=\hat{P} \cdot \hat{\mathcal{A}} \cdot \hat{P}+\hat{P} \cdot \hat{\mathcal{A}} \cdot \hat{Q}+\hat{Q} \cdot \hat{\mathcal{A}} \cdot \hat{P}+\hat{Q} \cdot \hat{\mathcal{A}} \cdot \hat{Q} \\= \underbrace{\sum_{i j} A_{i j}|i\rangle\langle j|}_{\text {within described subspace }}+\underbrace{\hat{P} \cdot \hat{\mathcal{A}} \cdot \hat{Q}+\hat{Q} \cdot \hat{\mathcal{A}} \cdot \hat{P}}_{\text {neglected coupling to (high-energy) part }}+\underbrace{\hat{Q} \cdot \hat{\mathcal{A}} \cdot \hat{Q}}_{\text {neglected (high-energy) part }},</script><script type="math/tex; mode=display">|\psi\rangle=1\cdot|\psi\rangle=(\hat{P}+\hat{Q})\cdot|\psi\rangle=\underbrace{\sum_i\psi_i |i\rangle}_{\text{within described subspace}}+\underbrace{\hat{Q}|\psi\rangle}_{\text{neglected (high-energy) part}}.</script><h2 id="2-时不变薛定谔方程"><a href="#2-时不变薛定谔方程" class="headerlink" title="2 时不变薛定谔方程"></a>2 时不变薛定谔方程</h2><p>数学语言为：</p><script type="math/tex; mode=display">\hat{\mathcal{H}}|\psi\rangle=E|\psi\rangle,</script><p><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\sum_jH_{mj}\psi_j=E\psi_m,</script><p>其向量形式为$H\cdot\vec{\psi}=E\vec{\boldsymbol{\psi}}$.</p><h2 id="3-时变薛定谔方程"><a href="#3-时变薛定谔方程" class="headerlink" title="3 时变薛定谔方程"></a>3 时变薛定谔方程</h2><p>数学语言为：</p><script type="math/tex; mode=display">\mathrm{i}\hbar\frac{\mathrm{d}}{\mathrm{d}t}|\psi(t)\rangle=\hat{\mathcal{H}}(t)|\psi(t)\rangle,</script><p>解方程得到：<br>$|\psi(t)\rangle=\hat{\mathcal{U}}(t_0;t)|\psi(t_0)\rangle$, 其中$\hat{\mathcal{U}}(t_0;t)$为传播子，对其用Magnus expansion得到$\hat{\mathcal{U}}(t_0;t)=\exp\left[\sum_{k=1}^\infty\hat{\Omega}_k(t_0;t)\right]$.</p><h3 id="3-1-假设基矢时不变，去解方程"><a href="#3-1-假设基矢时不变，去解方程" class="headerlink" title="3.1 假设基矢时不变，去解方程"></a>3.1 假设基矢时不变，去解方程</h3><p>假设$\hat{\mathcal{H}}(t)=\sum_{ij}H_{ij}(t) |i\rangle\langle j|$, $|\psi(t)\rangle=\sum\psi_i(t)\mid i\rangle$, 带入时变薛定谔方程，可以得到<br><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\mathrm{i}\hbar\dot{\psi}_m(t)=\sum_kH_{mk}(t)\psi_k(t),</script><p>其向量形式为$\mathrm{i}\hbar\dot{\vec{\boldsymbol{\psi}}}(t)=H(t)\cdot\vec{\boldsymbol{\psi}}(t)$.</p><h3 id="3-2-假设基矢时变，去解方程（用于相互作用图景）"><a href="#3-2-假设基矢时变，去解方程（用于相互作用图景）" class="headerlink" title="3.2 假设基矢时变，去解方程（用于相互作用图景）"></a>3.2 假设基矢时变，去解方程（用于相互作用图景）</h3><p>相互作用下哈密顿量为：$\hat{\mathcal{H}}(t)=\hat{\mathcal{H}}_0+\hat{\mathcal{H}}_1(t)$. 假设$\hat{\mathcal{H}}_0$可以对角化，即$\hat{\mathcal{H}}_0|i\rangle=E_i|i\rangle$, 则时变基矢表达式为：$|i(t)\rangle=e^{-\mathrm{i}E_it/\hbar}|i\rangle$, 于是可以将量子态用时变基展开：</p><script type="math/tex; mode=display">|\psi(t)\rangle=\sum_i\psi_i(t)\mid i(t)\rangle=\sum_i\psi_i(t)e^{-\mathrm{i}E_it/\hbar}|i\rangle,</script><p>将之带入时变薛定谔方程，可以得到<br><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\mathrm{i}\hbar\dot{\psi}_k(t)=\sum_j\psi_j(t)e^{-\mathrm{i}(E_j-E_k)t/\hbar}\langle k|\hat{\mathcal{H}}_1(t)|j\rangle=\sum_j\psi_j(t)e^{-\mathrm{i}(E_j-E_k)t/\hbar}{\mathcal{H}}_{1_{kj}}(t).</script><h3 id="3-3-特殊情况：-left-hat-mathcal-H-t-hat-mathcal-H-t’-right-0-forall-t-t’"><a href="#3-3-特殊情况：-left-hat-mathcal-H-t-hat-mathcal-H-t’-right-0-forall-t-t’" class="headerlink" title="3.3 特殊情况： $\left[\hat{\mathcal{H}}(t),\hat{\mathcal{H}}(t’)\right]=0 \forall(t,t’)$"></a>3.3 特殊情况： $\left[\hat{\mathcal{H}}(t),\hat{\mathcal{H}}(t’)\right]=0 \forall(t,t’)$</h3><p>可以直接解出薛定谔方程，其<br><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\vec{\boldsymbol{\psi}}(t)=\exp\left[-\frac{\mathrm{i}}{\hbar}\int_{t_0}^t\boldsymbol{H}(s)\mathrm{d}s\right]\cdot\vec{\boldsymbol{\psi}}(t_0).</script><h3 id="3-4-特殊情况：-哈密顿量是时不变的"><a href="#3-4-特殊情况：-哈密顿量是时不变的" class="headerlink" title="3.4 特殊情况： 哈密顿量是时不变的"></a>3.4 特殊情况： 哈密顿量是时不变的</h3><p>可以直接解出薛定谔方程，其<br><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\vec{\boldsymbol{\psi}}(t)=\exp\left[-\frac{\mathrm{i}(t-t_0)}\hbar\boldsymbol{H}\right]\cdot\vec{\boldsymbol{\psi}}(t_0).</script><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">phi:= = Flatten[KroneckerProduct[ phi1, phi2, phi3]]</code></pre><h2 id="4-基矢的计算机构造"><a href="#4-基矢的计算机构造" class="headerlink" title="4 基矢的计算机构造"></a>4 基矢的计算机构造</h2><h3 id="4-1-多维系统的描述"><a href="#4-1-多维系统的描述" class="headerlink" title="4.1 多维系统的描述"></a>4.1 多维系统的描述</h3><p>多维量子态的数学描述如下：</p><script type="math/tex; mode=display">\begin{aligned}|\psi\rangle=\left[\sum_{i_1=1}^{n_1}\psi_{i_1}^{(1)}|i_1\rangle^{(1)}\right]\otimes\left[\sum_{i_2=1}^{n_2}\psi_{i_2}^{(2)}|i_2\rangle^{(2)}\right]\otimes\cdots\otimes\left[\sum_{i_N=1}^{n_N}\psi_{i_N}^{(N)}|i_N\rangle^{(N)}\right]\\&\\=\sum_{i_1=1}^{n_1}\sum_{i_2=1}^{n_2}\cdots\sum_{i_N=1}^{n_N}\left[\psi_{i_1}^{(1)}\psi_{i_2}^{(2)}\ldots\psi_{i_N}^{(N)}\right]|i_1,i_2,\ldots,i_N\rangle\end{aligned},</script><p><strong>计算机语言</strong>为：<br></p><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">U[∆t_?NumericQ] := MatrixExp[-I*H*N[∆t]/~]</code></pre><br>多维算符的数学描述如下：<p></p><script type="math/tex; mode=display">\begin{aligned}\hat{A}=\left[\sum_{i_{1}=1}^{n_{1}}\sum_{j_{1}=1}^{n_{1}}a_{i_{1},j_{1}}^{(1)}|i_{1}\rangle^{(1)}\langle j_{1}|^{(1)}\right]\otimes\left[\sum_{i_{2}=1}^{n_{2}}\sum_{j_{2}=1}^{n_{2}}a_{i_{2},j_{2}}^{(2)}|i_{2}\rangle^{(2)}\langle j_{2}|^{(2)}\right]\otimes\cdots\otimes\left[\sum_{i_{N}=1}^{n_{N}}\sum_{i_{N}=1}^{n_{N}}a_{i_{N},j_{N}}^{(N)}|i_{N}\rangle^{(N)}\langle j_{N}|^{(N)}\right]\\&\\=\sum_{i_{1}=1}^{n_{1}}\sum_{j_{1}=1}^{n_{1}}\sum_{i_{2}=1}^{n_{2}}\sum_{j_{2}=1}^{n_{2}}\cdots\sum_{i_{N}=1}^{n_{N}}\sum_{j_{N}=1}^{n_{N}}\left[a_{i_{1}j_{1}}^{(1)}a_{i_{2}j_{2}}^{(2)}\cdots a_{i_{N}j_{N}}^{(N)}\right]|i_{1},i_{2},\ldots,i_{N}\rangle\langle j_{1},j_{2},\ldots,j_{N}|.\end{aligned}</script><p><strong>计算机语言</strong>为：<br></p><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">A = KroneckerProduct[a1, a2, a3]</code></pre><br>我们经常考察作用在某一成员空间的算符，这种算符的<br><strong>计算机语言</strong>（假设为三体系统）为<br><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">H1 = KroneckerProduct[h1,                    IdentityMatrix[Dimensions[h2]],                    IdentityMatrix[Dimensions[h3]]];H2 = KroneckerProduct[IdentityMatrix[Dimensions[h1]],                    h2,                    IdentityMatrix[Dimensions[h3]]];H3 = KroneckerProduct[IdentityMatrix[Dimensions[h1]],                    IdentityMatrix[Dimensions[h2]],                    h3];</code></pre><p></p><h3 id="4-2-偏迹的描述"><a href="#4-2-偏迹的描述" class="headerlink" title="4.2 偏迹的描述"></a>4.2 偏迹的描述</h3><p>数学描述如下，假如有一个三体系统：</p><script type="math/tex; mode=display">\hat{\rho}_{\mathrm{ABC}}=\sum_{i,i^{\prime}=1}^{d_{\mathrm{A}}}\sum_{j,j^{\prime}=1}^{d_{\mathrm{B}}}\sum_{k,k^{\prime}=1}^{d_{\mathrm{C}}}\rho_{i,j,k,i^{\prime},j^{\prime},k^{\prime}}|i_{\mathrm{A}},j_{\mathrm{B}},k_{\mathrm{C}}\rangle\langle i_{\mathrm{A}}^{\prime},j_{\mathrm{B}}^{\prime},k_{\mathrm{C}}^{\prime}|,</script><p>其中$\rho$是个6维张量。对B求偏迹的数学公式为：</p><script type="math/tex; mode=display">\begin{gathered}\hat{\rho}_{\mathrm{AC}}=\sum_{j^{\prime\prime}=1}^{d_{\mathrm{B}}}\langle j_{\mathrm{B}}^{\prime\prime}|\hat{\rho}_{\mathrm{ABC}}|j_{\mathrm{B}}^{\prime\prime}\rangle\\=\sum_{j^{\prime\prime}=1}^{d_{\mathrm{B}}}\langle j_{\mathrm{B}}^{\prime\prime}|\left\lfloor\sum_{i,i^{\prime}=1}^{d_{\mathrm{A}}}\sum_{j,j^{\prime}=1}^{d_{\mathrm{B}}}\sum_{k,k^{\prime}=1}^{d_{\mathrm{C}}}\rho_{i,j,k,i^{\prime},j^{\prime},k^{\prime}}|i_{\mathrm{A}},j_{\mathrm{B}},k_{\mathrm{C}}\rangle\langle i_{\mathrm{A}}^{\prime},j_{\mathrm{B}}^{\prime},k_{\mathrm{C}}^{\prime}|\right\rfloor|j_{\mathrm{B}}^{\prime\prime}\rangle \\=\sum_{j^{\prime\prime}=1}^{d_{B}}\sum_{i,i^{\prime}=1}^{d_{A}}\sum_{j,j=1}^{d_{B}}\sum_{k,k^{\prime}=1}^{d_{C}}\rho_{i,j,k,i^{\prime},j^{\prime},k^{\prime}}\langle j_{B}^{\prime\prime}|i_{A},j_{B},k_{C}\rangle\langle i_{A}^{\prime},j_{B}^{\prime},k_{C}^{\prime}|j_{B}^{\prime\prime}\rangle\\=\sum_{j^{\prime\prime}=1}^{d_{B}}\sum_{i,i^{\prime}=1}^{d_{A}}\sum_{j,j^{\prime}=1}^{d_{B}}\sum_{k,k^{\prime}=1}^{d_{C}}\rho_{i,j,k,i^{\prime},j^{\prime},k^{\prime}}[\delta_{j^{\prime\prime},j}|i_{A},k_{C}\rangle]\left[\delta_{j^{\prime\prime},j^{\prime}}\langle i_{A}^{\prime},k_{C}^{\prime}\right|] \\=\sum_{i,i^{\prime}=1}^{d_{A}}\sum_{k,k^{\prime}=1}^{d_{C}}\left[\sum_{j=1}^{d_{B}}\rho_{i,j,k,i^{\prime},j,k^{\prime}}\right]|i_{A},k_{C}\rangle\langle i_{A}^{\prime},k_{C}^{\prime}|,\end{gathered}</script><p>可见这是对6维张量在2&amp;5维上的压缩操作。<br>所以用<strong>计算机语言</strong>去表示偏迹，可以先把$\hat{\rho}_{\mathrm{ABC}}$重塑成6维张量：<br></p><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">R = ArrayReshape[ρABC, {dA,dB,dC,dA,dB,dC}]</code></pre><br>然后在2&amp;5维上进行压缩操作：<br><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">S = TensorContract[R, {2,5}]</code></pre><br>最后再还原成密度矩阵形式(2维张量)：<br><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">ρAC = Flatten[S, {{1,2}, {3,4}}]</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> mathematica </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathematica, quantum mechanics </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
