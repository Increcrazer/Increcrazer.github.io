<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>两种统计分布</title>
      <link href="/2024/12/29/liang-chong-tong-ji-fen-bu/"/>
      <url>/2024/12/29/liang-chong-tong-ji-fen-bu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-高斯分布"><a href="#1-高斯分布" class="headerlink" title="1 高斯分布"></a>1 高斯分布</h2><ul><li><p>定义<br>  <img src="https://s2.loli.net/2024/12/29/Y268SLQPHKnDbsR.png" alt=""></p><script type="math/tex; mode=display">  \begin{aligned}  y  &=y_0+\frac{A}{w\sqrt{\pi/2}}e^{-2\frac{(x-x_c)^2}{w^2}}\\  &=y_0+\frac{A}{\sigma\sqrt{2\pi}}e^{-\frac{(x-x_c)^2}{2\sigma^2}}  \end{aligned}</script><script type="math/tex; mode=display">  w=2\sigma</script><script type="math/tex; mode=display">  \mathrm{FWHM}=2\sqrt{2\ln2}\sigma\approx2.355\sigma</script></li><li><p>方差的线性可加性</p><p>  如果</p><script type="math/tex; mode=display">  \begin{array}  {l}X\sim N(\mu_X,\sigma_X^2) \\  \\  Y\sim N(\mu_Y,\sigma_Y^2) \\  \\  Z=X+Y,  \end{array}</script><p>  则</p><script type="math/tex; mode=display">  Z \sim N\left(\mu_{X}+\mu_{Y}, \sigma_{X}^{2}+\sigma_{Y}^{2}\right)</script><p> 下面这个工具计算同一个高斯分布中，以$x_c$为中心的宽度$w_2$内积分与宽度$w_1$内积分之比。可以验证所谓$n\sigma$原则：</p><p> $\sigma$原则：数值分布在$(\mu-\sigma,\mu+\sigma)$中的概率为0.6826；</p><p> $2\sigma$原则：数值分布在$(\mu-2\sigma,\mu+2\sigma)$中的概率为0.9544；</p><p> $3\sigma$原则：数值分布在$(\mu-3\sigma,\mu+3\sigma)$中的概率为0.9974；<br> <img src="https://s2.loli.net/2024/12/29/SwoMYuNfeO4TJCQ.png" alt=""></p> <table border="1">  <tbody><tr>    <th>标准差 (σ)</th>    <th>宽度 w1 </th>    <th>宽度 w2 </th>    <th>积分比 (w2 / w1)</th>  </tr>  <!-- 第一行 -->  <tr>    <td><input id="sigma_1" type="number" value="1" min="0" step="0.1" oninput="calculateRow(1)"></td>    <td><input id="w1_1" type="number" value="3" min="0" step="0.1" oninput="calculateRow(1)"></td>    <td><input id="w2_1" type="number" value="2" min="0" step="0.1" oninput="calculateRow(1)"></td>    <td id="result_1">-</td>  </tr>  <!-- 第二行 -->  <tr>    <td><input id="sigma_2" type="number" value="2" min="0" step="0.1" oninput="calculateRow(2)"></td>    <td><input id="w1_2" type="number" value="4" min="0" step="0.1" oninput="calculateRow(2)"></td>    <td><input id="w2_2" type="number" value="3" min="0" step="0.1" oninput="calculateRow(2)"></td>    <td id="result_2">-</td>  </tr>  <!-- 第三行 -->  <tr>    <td><input id="sigma_3" type="number" value="1.5" min="0" step="0.1" oninput="calculateRow(3)"></td>    <td><input id="w1_3" type="number" value="2" min="0" step="0.1" oninput="calculateRow(3)"></td>    <td><input id="w2_3" type="number" value="1.5" min="0" step="0.1" oninput="calculateRow(3)"></td>    <td id="result_3">-</td>  </tr>  <!-- 第四行 -->  <tr>    <td><input id="sigma_4" type="number" value="0.8" min="0" step="0.1" oninput="calculateRow(4)"></td>    <td><input id="w1_4" type="number" value="5" min="0" step="0.1" oninput="calculateRow(4)"></td>    <td><input id="w2_4" type="number" value="4" min="0" step="0.1" oninput="calculateRow(4)"></td>    <td id="result_4">-</td>  </tr>  <!-- 第五行 -->  <tr>    <td><input id="sigma_5" type="number" value="2.5" min="0" step="0.1" oninput="calculateRow(5)"></td>    <td><input id="w1_5" type="number" value="6" min="0" step="0.1" oninput="calculateRow(5)"></td>    <td><input id="w2_5" type="number" value="5" min="0" step="0.1" oninput="calculateRow(5)"></td>    <td id="result_5">-</td>  </tr></tbody></table><script>// 高斯函数 (标准正态分布)function gaussian(x, sigma) {  return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow(x / sigma, 2));}// 数值积分 (使用梯形法则)function integrateGaussian(sigma, w) {  const steps = 10000; // 积分步数  const dx = (1 * w) / steps; // 步长  let sum = 0;  for (let i = 0; i <= steps; i++) {    let x = -w/2 + i * dx;    let weight = (i === 0 || i === steps) ? 0.5 : 1; // 梯形法则加权    sum += weight * gaussian(x, sigma);  }  return sum * dx;}// 计算积分比function calculateRow(row) {  // 获取输入值  var sigma = parseFloat(document.getElementById('sigma_' + row).value); // 标准差  var w1 = parseFloat(document.getElementById('w1_' + row).value); // 宽度 w1  var w2 = parseFloat(document.getElementById('w2_' + row).value); // 宽度 w2  // 计算积分  var integralW1 = integrateGaussian(sigma, w1);  var integralW2 = integrateGaussian(sigma, w2);  // 计算积分比  var ratio = integralW2 / integralW1;  // 显示结果  document.getElementById('result_' + row).innerText = ratio.toFixed(3);}window.onload = calculateRow(1);window.onload = calculateRow(2);window.onload = calculateRow(3);window.onload = calculateRow(4);window.onload = calculateRow(5);</script></li></ul><h2 id="2-洛伦兹分布"><a href="#2-洛伦兹分布" class="headerlink" title="2 洛伦兹分布"></a>2 洛伦兹分布</h2><ul><li><p>定义<br><img src="https://s2.loli.net/2024/12/29/mVv8jpqKHX6LzyI.png" alt=""></p><script type="math/tex; mode=display">\begin{aligned}y&=y_{0}+\frac{2 A}{\pi} \frac{w}{4\left(x-x_{c}\right)^{2}+w^{2}}\\&=y_{0}+\frac{A}{\pi}\left[\frac{\gamma}{(x-x_{c})^{2}+\gamma^{2}}\right]\end{aligned}</script><script type="math/tex; mode=display">\mathrm{FWHM}=w=2\gamma</script></li></ul>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math, tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股市常识（持续更新）</title>
      <link href="/2024/12/23/gu-shi-chang-shi-chi-xu-geng-xin/"/>
      <url>/2024/12/23/gu-shi-chang-shi-chi-xu-geng-xin/</url>
      
        <content type="html"><![CDATA[<h2 id="K线"><a href="#K线" class="headerlink" title="K线"></a>K线</h2><ul><li><strong>形态</strong><br>光头阳线和光脚阴线分别代表多方和空方的压倒性优势，极端就是T和倒T。<br>一字线、十字星、T和倒T说明可能已经变盘</li><li><strong>实体大小</strong><br>实体部分越大代表某一方力量越强</li><li><strong>影线大小</strong><br>上影线越长代表空方强势（因为空方往下压），<br>下影线越长代表多方强势（因为多方往上顶）</li></ul><h2 id="成交量"><a href="#成交量" class="headerlink" title="成交量"></a>成交量</h2><ul><li><strong>缩量</strong><br>成交量柱状图逐渐减小，极端是涨跌停</li><li><strong>放量</strong><br>成交量柱状图逐渐增大，说明多空都很多，分歧逐渐增大，可能要变盘，但容易被左手倒右手而造假</li><li><strong>堆量</strong><br>三角形形态</li><li><strong>不规则成交量</strong><br>巨大成交量，往往是小庄和柚子搞的</li></ul><h2 id="量价关系（重点）"><a href="#量价关系（重点）" class="headerlink" title="量价关系（重点）"></a>量价关系（重点）</h2><ul><li><p><strong>量价配合</strong><br>即成交量和股价成正比</p><ul><li>上涨时量增价升表后市看多</li><li>下跌时量缩价跌表底部即现</li><li>底部出现量增价升表后市看涨</li><li>顶部出现量缩价跌表后市看跌</li></ul></li><li><p><strong>量价背离</strong><br>即成交量和股价成反比</p><ul><li>上涨时量缩价升表股价随时可能快速下跌</li><li>下跌时量增价跌表恐慌，因为看空越来越多，后续可能会崩盘</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> economics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stock, leek </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性和非线性效应公式速查</title>
      <link href="/2024/12/17/xian-xing-he-fei-xian-xing-xiao-ying-gong-shi-su-cha/"/>
      <url>/2024/12/17/xian-xing-he-fei-xian-xing-xiao-ying-gong-shi-su-cha/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线性效应"><a href="#1-线性效应" class="headerlink" title="1 线性效应"></a>1 线性效应</h2><ul><li><p>对$n(\omega)$在$\omega_0$处展开</p><script type="math/tex; mode=display">n(\omega)=n(\omega)=n_0+n_1(\omega-\omega_0)+\frac{1}{2!}n_2(\omega-\omega_0)^2+\frac{1}{3!}n_3(\omega-\omega_0)^3+\cdots</script><script type="math/tex; mode=display">n_i=(\frac{d^in}{d\omega^i})_{\omega=\omega_0}</script><p><strong><em>注：这里采用笔者的书写习惯，$n_2$并非kerr系数。表示非线性均用大写$N$.</em></strong></p></li><li><p>对$\beta(\omega)$在$\omega_0$处展开</p><script type="math/tex; mode=display">\beta(\omega)=n(\omega)\frac{\omega}{c}=\beta_0+\beta_1(\omega-\omega_0)+\frac{1}{2!}\beta_2(\omega-\omega_0)^2+\frac{1}{3!}\beta_3(\omega-\omega_0)^3+\cdots</script><script type="math/tex; mode=display">\beta_i=(\frac{d^i\beta}{d\omega^i})_{\omega=\omega_0}=(\omega n_i+in_{i-1})/c</script><p>其中一次项和二次项需要关注，它们分别称作<strong>一阶色散/群延迟</strong>和<strong>二阶色散</strong></p><script type="math/tex; mode=display">\beta_1=(\omega n_1+n)/c=1/v_g</script><script type="math/tex; mode=display">\beta_2=(\omega n_2+2n_1)/c</script></li><li><p>对$\omega({\mu})$在$\mu=0处$展开，$\omega({\mu})$代表周期性频谱的谐振角频率</p><script type="math/tex; mode=display">\omega(\mu)=\omega_{0}+D_{1} \mu+\frac{D_{2}}{2!} \mu^{2}+\frac{D_{3}}{3!} \mu^{3}+\ldots \quad(\mu=\ldots-3,-2,-1,0,1,2,3 \ldots)</script><script type="math/tex; mode=display">D_i=(\frac{d^i\omega}{d\mu^i})_{\omega=\omega_0}</script><p>由于$m$和$\mu$是同一个物理量，所以$n(\omega)\cdot\omega\cdot L/c=2\pi m$两边分别对$m$求导可得$D_i$.<br>其中一次项和二次项需要关注，它们分别称作<strong>一阶色散系数/FSR</strong>和<strong>二阶群速度色散系(2-order GVD)</strong>：</p><script type="math/tex; mode=display">D_1=\frac{2\pi}{\beta_1L}=2\pi\frac{v_g}{L}=FSR(rad/s)</script><script type="math/tex; mode=display">D_2=-\frac{\beta_2D_1^2}{\beta_1}(rad/s)</script></li><li><p>色散参量</p><script type="math/tex; mode=display">D=\frac{d\beta_1}{d\lambda}=\frac{d}{d\omega}\left(\frac{d\beta}{d\omega}\right)\cdot\frac{d\omega}{d\lambda}=\beta_2\cdot\frac{d\omega}{d\lambda}</script><script type="math/tex; mode=display">\frac{d\omega}{d\lambda}=-\frac{2\pi c}{\lambda^2}</script><script type="math/tex; mode=display">D=-\beta_2\cdot\frac{2\pi c}{\lambda^2}(s/m^2)</script><p>其单位一般为ps/nm/km，描述光纤或波导中波长引起的脉冲展宽。该物理量和$D_2$不同，后者代表FSR随模序的变化。</p></li><li><p>正常色散和反常色散<br>正常色散：$\beta_2&gt;0,D&lt;0,D_2&lt;0$,低频快</p><p>反常色散：$\beta_2&lt;0,D&gt;0,D_2&gt;0$,高频快</p></li></ul><h2 id="2-非线性效应"><a href="#2-非线性效应" class="headerlink" title="2 非线性效应"></a>2 非线性效应</h2><ul><li><p>3阶非线性(Kerr)</p><script type="math/tex; mode=display">\begin{aligned}\vec{P} &= \vec{P}^{(1)} + \vec{P}^{(2)} + \vec{P}^{(3)} + \cdots \\&= \boldsymbol{\varepsilon}_0\left(\boldsymbol{\chi}^{(1)} \cdot \vec{E}     + \boldsymbol{\chi}^{(2)} {:} \vec{E} \vec{E}     + \boldsymbol{\chi}^{(3)} {:} \vec{E} \vec{E} \vec{E}     + \cdots\right),\end{aligned}</script><p>:表示高阶张量乘积。每个维度上的极化强度为：</p><script type="math/tex; mode=display">\begin{aligned}P_i&= {P_i}^{(1)}+{P_i}^{(2)}+{P_i}^{(3)} \\&= \boldsymbol{\varepsilon}_0\left(\sum_{j}\chi_{ij}^{(1)}E_{1j}+\sum_{jk}\chi_{ijk}^{(2)}E_{1j}E_{2k}+\sum_{jkl}\chi_{ijkl}^{(3)}E_{1j}E_{2k}E_{3l}+\cdots\right),(i,j,k...\in\{x,y,z\})\end{aligned}</script><p>假设所有电场同一个方向极化，且我们只考虑该方向上的极化强度（因为我们的目的是求出该方向上的折射率，只有该方向上的折射率会影响电场），所以极化强度可退化为标量形式：</p><script type="math/tex; mode=display">P(\boldsymbol{r},t)=\epsilon_0\left(\chi^{(1)}E(\boldsymbol{r},t)+\chi^{(2)}E^2(\boldsymbol{r},t)+\chi^{(3)}E^3(\boldsymbol{r},t)+\ldots\right)</script><p>再着重考虑Kerr效应：</p><script type="math/tex; mode=display">P^{(3)}(\boldsymbol{r},t)=\epsilon_{0}\chi^{(3)}\left(E_{1}(\boldsymbol{r})e^{i\omega_{1}t}+E_{2}(\boldsymbol{r})e^{i\omega_{2}t}+E_{3}(\boldsymbol{r})e^{i\omega_{3}t}+\mathrm{c.c.}\right)^{3}</script><p>去掉44项中相消的项，得到：</p><script type="math/tex; mode=display">P^{(3)}(\boldsymbol{r},t)=\epsilon_0\chi^{(3)}\left(E(\boldsymbol{r})\cos\omega t\right)^3=\frac{1}{4}\epsilon_0\chi^{(3)}E^3(\boldsymbol{r})\cos3\omega t+\frac{3}{4}\epsilon_0\chi^{(3)}E^3(\boldsymbol{r})\cos\omega t</script><p>我们只需要三次项，因为一次项归于泵浦被滤除。于是可得：</p><script type="math/tex; mode=display">P^{(3)}(\boldsymbol{r},t)=\frac{3}{4}\epsilon_0\chi^{(3)}E^3(\boldsymbol{r})\cos\omega t=\epsilon_0\epsilon_{NL}E(\boldsymbol{r},t)</script><script type="math/tex; mode=display">\epsilon_{NL}=\frac{3}{4}\chi^{(3)}|E(\boldsymbol{r},t)|^2</script><script type="math/tex; mode=display">\begin{aligned}n^{\prime}&=\left(1+\chi^{(1)}+\epsilon_{NL}\right)^{1/2}\\&\approx n+\frac{\epsilon_{NL}}{2n}\\&=n+N_2I\\&=n+(3\chi^{(3)}/4n^2\epsilon_0c)*(n\epsilon_0c|E|^2/2)\end{aligned}</script><p>另外定义$\gamma$:</p><script type="math/tex; mode=display">\gamma=\frac{\omega_0N_2}{cA_\mathrm{eff}}</script></li><li><p>Kerr腔体光学</p><ul><li><p>Ikeda Map</p><ul><li><p>未归一化</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial A}{\partial z}&=-\frac{\alpha_{i}}{2}A-i\frac{\beta_{2}}{2}\frac{\partial^{2}A}{\partial t^{2}}+i\gamma|A|^{2}A,\\A^{m+1}(0,t)&=\sqrt{1-\theta}e^{-i\delta}A^{m}(L,t)+\sqrt{\theta}A_{\mathrm{in}}\end{aligned}</script></li><li><p>归一化</p><script type="math/tex; mode=display">\begin{aligned}\frac{\partial\psi^{m}}{\partial\xi}&=-\frac{\alpha}{2}\psi^m-is\frac{\partial^2\psi^m}{\partial\tau^2}+i|\psi^m|^2\psi^m,\\\psi^{m+1}(0,\tau)&=\sqrt{1-\alpha}e^{-i\delta}\psi^{m}(1,\tau)+\sqrt{\alpha}\psi_{\mathrm{in}}.\end{aligned}</script></li></ul></li><li><p>LLE(本质是Ikeda Map精简版，适用于慢变光场，减小计算量)</p><ul><li>归一化<script type="math/tex; mode=display">\frac{\partial\psi}{\partial\eta}=-\left(\alpha+i\delta\right)\psi-is\frac{\partial^{2}\psi}{\partial\tau^{2}}+i{\left|\psi\right|}^{2}\psi+\sqrt{\alpha}\psi_{\mathrm{in}}</script></li></ul></li><li><p>归一化系数等参数</p><script type="math/tex; mode=display">\xi=\frac{z}{z_0},\quad\tau=\frac{t}{t_0},\quad\psi=\frac{A}{A_0},\quad\psi_{in}=\frac{A_{in}}{A_0}</script><script type="math/tex; mode=display">z_0=L,\quad t_0=\sqrt{\frac{|\beta_2|L}{2}},\quad A_0=\sqrt{\frac{1}{L\gamma}}</script></li></ul></li></ul><script>  function calculateRow(row) {    // 获取输入值    var lambda = parseFloat(document.getElementById('lambda_' + row).value); // λ (nm)    var n = parseFloat(document.getElementById('n_' + row).value); // n (有效折射率的正数部分)    var beta2 = parseFloat(document.getElementById('beta2_' + row).value); // β2    var chi3 = parseFloat(document.getElementById('chi3_' + row).value); // chi3    var r = parseFloat(document.getElementById('r_' + row).value); // r (um)    var Aeff = parseFloat(document.getElementById('Aeff_' + row).value); // Aeff (nm^2)    // 计算公式    var L = 2 * Math.PI * r; // L(um)    var N2 = (3 * chi3) / (4 * Math.pow(n, 2) * 8.854187817e-12 * 3e8); // N2(m^2/W)    var gamma = (2 * Math.PI * N2) / (lambda * 1e-9 * Aeff * 1e-18); // γ(标准单位)    var t0 = Math.sqrt(Math.abs(beta2) * L * 1e-6 / 2) * 1e15; // t0(fs)    var A0 = Math.sqrt(1 / (L * 1e-6 * gamma)); // A0(V/m)    // 显示结果    document.getElementById('L_' + row).innerText = L.toFixed(3);    document.getElementById('N2_' + row).innerText = N2.toExponential(3);    document.getElementById('gamma_' + row).innerText = gamma.toExponential(3);    document.getElementById('t0_' + row).innerText = t0.toFixed(3);    document.getElementById('A0_' + row).innerText = A0.toExponential(3);  }  // 页面加载时自动计算初始值  window.onload = function () {    for (let i = 1; i <= 5; i++) {      calculateRow(i);    }  };</script><table border="1">  <tbody><tr>    <th>真空λ (nm)</th>    <th>n (有效折射率的实数部分)</th>    <th>β2</th>    <th>chi3</th>    <th>r (um)</th>    <th>Aeff (nm²)</th>    <th>L (um)</th>    <th>N2 (m²/W)</th>    <th>γ (标准单位)</th>    <th>t0 (fs)</th>    <th>A0 (V/m)</th>  </tr>  <!-- 第一行 -->  <tr>    <td><input id="lambda_1" type="number" value="1550" min="0" step="1" oninput="calculateRow(1)"></td>    <td><input id="n_1" type="number" value="4" min="0" step="0.01" oninput="calculateRow(1)"></td>    <td><input id="beta2_1" type="number" value="1e-26" step="1e-26" oninput="calculateRow(1)"></td>    <td><input id="chi3_1" type="number" value="1e-18" step="1e-18" oninput="calculateRow(1)"></td>    <td><input id="r_1" type="number" value="100" min="0" step="1" oninput="calculateRow(1)"></td>    <td><input id="Aeff_1" type="number" value="3" min="0" step="1" oninput="calculateRow(1)"></td>    <td id="L_1">-</td>    <td id="N2_1">-</td>    <td id="gamma_1">-</td>    <td id="t0_1">-</td>    <td id="A0_1">-</td>  </tr>  <!-- 第二行 -->  <tr>    <td><input id="lambda_2" type="number" value="1550" min="0" step="1" oninput="calculateRow(2)"></td>    <td><input id="n_2" type="number" value="4" min="0" step="0.01" oninput="calculateRow(2)"></td>    <td><input id="beta2_2" type="number" value="1e-26" step="1e-26" oninput="calculateRow(2)"></td>    <td><input id="chi3_2" type="number" value="1e-18" step="1e-18" oninput="calculateRow(2)"></td>    <td><input id="r_2" type="number" value="100" min="0" step="1" oninput="calculateRow(2)"></td>    <td><input id="Aeff_2" type="number" value="3" min="0" step="1" oninput="calculateRow(2)"></td>    <td id="L_2">-</td>    <td id="N2_2">-</td>    <td id="gamma_2">-</td>    <td id="t0_2">-</td>    <td id="A0_2">-</td>  </tr>  <!-- 第三行 -->  <tr>    <td><input id="lambda_3" type="number" value="1550" min="0" step="1" oninput="calculateRow(3)"></td>    <td><input id="n_3" type="number" value="4" min="0" step="0.01" oninput="calculateRow(3)"></td>    <td><input id="beta2_3" type="number" value="1e-26" step="1e-26" oninput="calculateRow(3)"></td>    <td><input id="chi3_3" type="number" value="1e-18" step="1e-18" oninput="calculateRow(3)"></td>    <td><input id="r_3" type="number" value="100" min="0" step="1" oninput="calculateRow(3)"></td>    <td><input id="Aeff_3" type="number" value="3" min="0" step="1" oninput="calculateRow(3)"></td>    <td id="L_3">-</td>    <td id="N2_3">-</td>    <td id="gamma_3">-</td>    <td id="t0_3">-</td>    <td id="A0_3">-</td>  </tr>  <!-- 第四行 -->  <tr>    <td><input id="lambda_4" type="number" value="1550" min="0" step="1" oninput="calculateRow(4)"></td>    <td><input id="n_4" type="number" value="4" min="0" step="0.01" oninput="calculateRow(4)"></td>    <td><input id="beta2_4" type="number" value="1e-26" step="1e-26" oninput="calculateRow(4)"></td>    <td><input id="chi3_4" type="number" value="1e-18" step="1e-18" oninput="calculateRow(4)"></td>    <td><input id="r_4" type="number" value="100" min="0" step="1" oninput="calculateRow(4)"></td>    <td><input id="Aeff_4" type="number" value="3" min="0" step="1" oninput="calculateRow(4)"></td>    <td id="L_4">-</td>    <td id="N2_4">-</td>    <td id="gamma_4">-</td>    <td id="t0_4">-</td>    <td id="A0_4">-</td>  </tr>  <!-- 第五行 -->  <tr>    <td><input id="lambda_5" type="number" value="1550" min="0" step="1" oninput="calculateRow(5)"></td>    <td><input id="n_5" type="number" value="4" min="0" step="0.01" oninput="calculateRow(5)"></td>    <td><input id="beta2_5" type="number" value="1e-26" step="1e-26" oninput="calculateRow(5)"></td>    <td><input id="chi3_5" type="number" value="1e-18" step="1e-18" oninput="calculateRow(5)"></td>    <td><input id="r_5" type="number" value="100" min="0" step="1" oninput="calculateRow(5)"></td>    <td><input id="Aeff_5" type="number" value="3" min="0" step="1" oninput="calculateRow(5)"></td>    <td id="L_5">-</td>    <td id="N2_5">-</td>    <td id="gamma_5">-</td>    <td id="t0_5">-</td>    <td id="A0_5">-</td>  </tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> photonics, tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微腔参数计算工具</title>
      <link href="/2024/12/03/wei-qiang-can-shu-ji-suan-gong-ju/"/>
      <url>/2024/12/03/wei-qiang-can-shu-ji-suan-gong-ju/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/12/03/MRpbCKg2SDXBk5N.png" alt=""></p><h2 id="1-公式"><a href="#1-公式" class="headerlink" title="1 公式"></a>1 公式</h2><script type="math/tex; mode=display">k^{2}+r^{2}=1</script><script type="math/tex; mode=display">a^{2}=\exp(-\alpha L)</script><script type="math/tex; mode=display">\mathrm{FSR(length)}=\frac{\lambda^{2}}{n_{g} L}</script><script type="math/tex; mode=display">\mathrm{FSR(freq)}=\frac{c}{n_{g} L}</script><script type="math/tex; mode=display">n_{g}=n_{\mathrm{eff}}-\lambda \frac{d n_{\mathrm{eff}}}{d \lambda}</script><script type="math/tex; mode=display">n_{g}=n_{\mathrm{eff}}+\omega \frac{d n_{\mathrm{eff}}}{d \omega}</script><script type="math/tex; mode=display">\mathrm { Finess }=\frac{\mathrm{FSR}}{\mathrm{FWHM}}</script><script type="math/tex; mode=display">\mathrm { Q-factor }=\frac{\mathrm{\lambda_{res}}}{\mathrm{FWHM}}</script><ul><li>All-pass<script type="math/tex; mode=display">\mathrm { Q-factor }=\frac{\pi n_{g} L \sqrt{r a}}{\lambda_{\mathrm{res}}(1-r a)}</script></li></ul><script type="math/tex; mode=display">\mathrm { Finess }=\frac{\pi \sqrt{r a}}{1-r a}</script><p>当$\alpha$和$k$很小时，</p><script type="math/tex; mode=display">\sqrt{r a}=\sqrt{1-k^2}\sqrt{a}\\≈(1-0.5k^2)\exp(-0.5\alpha L)\\≈\exp(-0.5k^2)\exp(-0.5\alpha L)\\=\exp(-0.5k^2-0.5\alpha L)</script><p>设$\alpha_{tot}=0.5k^2+0.5\alpha L$，则</p><script type="math/tex; mode=display">\sqrt{r a}=\exp(-\alpha_{tot})</script><script type="math/tex; mode=display">\mathrm { Finess }=\frac{\pi \sqrt{r a}}{1-r a}\\=\frac{\pi}{\frac{1}{\sqrt{r a}}-\sqrt{r a}}\\=\frac{\pi}{\exp(\alpha_{tot})-\exp(-\alpha_{tot})}\\≈\frac{\pi}{2\alpha_{tot}}</script><ul><li>Add-drop<script type="math/tex; mode=display">\text { Q-factor }=\frac{\pi n_{g} L \sqrt{r_{1} r_{2} a}}{\lambda_{\text {res }}\left(1-r_{1} r_{2} a\right)}</script></li></ul><script type="math/tex; mode=display">\text { Finess }=\frac{\pi \sqrt{r_{1} r_{2} a}}{1-r_{1} r_{2} a}</script><h2 id="2-转换器"><a href="#2-转换器" class="headerlink" title="2 转换器"></a>2 转换器</h2><div>  <h3>FSR 计算器</h3>  <table border="1">    <thead>      <tr>        <th>波长 (nm)</th>        <th>ng </th>        <th>半径 (µm)</th>        <th>FSR (nm)</th>        <th>FSR (THz)</th>      </tr>    </thead>    <tbody>      <tr>        <td><input type="number" id="wavelength1" value="1550" oninput="calculateFSR()"></td>        <td><input type="number" id="ng1" value="4.3" oninput="calculateFSR()"></td>        <td><input type="number" id="radius1" value="100" oninput="calculateFSR()"></td>        <td id="fsr_nm1">N/A</td>        <td id="fsr_thz1">N/A</td>      </tr>      <tr>        <td><input type="number" id="wavelength2" value="1560" oninput="calculateFSR()"></td>        <td><input type="number" id="ng2" value="4.4" oninput="calculateFSR()"></td>        <td><input type="number" id="radius2" value="120" oninput="calculateFSR()"></td>        <td id="fsr_nm2">N/A</td>        <td id="fsr_thz2">N/A</td>      </tr>      <tr>        <td><input type="number" id="wavelength3" value="1540" oninput="calculateFSR()"></td>        <td><input type="number" id="ng3" value="4.2" oninput="calculateFSR()"></td>        <td><input type="number" id="radius3" value="150" oninput="calculateFSR()"></td>        <td id="fsr_nm3">N/A</td>        <td id="fsr_thz3">N/A</td>      </tr>      <tr>        <td><input type="number" id="wavelength4" value="1530" oninput="calculateFSR()"></td>        <td><input type="number" id="ng4" value="4.5" oninput="calculateFSR()"></td>        <td><input type="number" id="radius4" value="80" oninput="calculateFSR()"></td>        <td id="fsr_nm4">N/A</td>        <td id="fsr_thz4">N/A</td>      </tr>      <tr>        <td><input type="number" id="wavelength5" value="1570" oninput="calculateFSR()"></td>        <td><input type="number" id="ng5" value="4.1" oninput="calculateFSR()"></td>        <td><input type="number" id="radius5" value="90" oninput="calculateFSR()"></td>        <td id="fsr_nm5">N/A</td>        <td id="fsr_thz5">N/A</td>      </tr>    </tbody>  </table></div><script>function calculateFSR() {    for (let i = 1; i <= 5; i++) {        var wavelength = parseFloat(document.getElementById('wavelength' + i).value);        var ng = parseFloat(document.getElementById('ng' + i).value);        var radius = parseFloat(document.getElementById('radius' + i).value);        if (!isNaN(wavelength) && !isNaN(ng) && !isNaN(radius) && wavelength > 0 && ng > 0 && radius > 0) {            var wavelength_m = wavelength * 1e-9;            var radius_m = radius * 1e-6;            var fsr_nm = (wavelength_m ** 2) / (ng * 2 * Math.PI * radius_m) * 1e9;            var fsr_thz = (3e8) / (ng * 2 * Math.PI * radius_m) * 1e-12;            document.getElementById('fsr_nm' + i).innerText = fsr_nm.toFixed(4);            document.getElementById('fsr_thz' + i).innerText = fsr_thz.toFixed(4);        } else {            document.getElementById('fsr_nm' + i).innerText = 'N/A';            document.getElementById('fsr_thz' + i).innerText = 'N/A';        }    }}// 页面加载时自动计算初始值window.onload = calculateFSR();</script><div>  <h3>Q因子 计算器</h3>  <table border="1">    <thead>      <tr>        <th>真空波长 (nm)</th>        <th>ng </th>        <th>α (1/cm) </th>        <th>半径 (µm)</th>        <th>直通系数1</th>        <th>直通系数2</th>        <th>Q因子</th>        <th>Finesse</th>      </tr>    </thead>    <tbody>      <tr>        <td><input type="number" id="wavelengthh1" value="1550" min="0" oninput="calculateQ(1)"></td>        <td><input type="number" id="ngg1" value="4.3" min="0" step="0.1" oninput="calculateQ(1)"></td>        <td><input type="number" id="alpha1" value="0.1" min="0" step="0.01" oninput="calculateQ(1)"></td>        <td><input type="number" id="radiuss1" value="100" min="0" oninput="calculateQ(1)"></td>        <td><input type="number" id="r1_1" value="0.7" min="0" max="1" step="0.01" oninput="calculateQ(1)"></td>        <td><input type="number" id="r2_1" value="1" min="0" max="1" step="0.01" oninput="calculateQ(1)"></td>        <td id="q_1">N/A</td>        <td id="finesse_1">N/A</td>      </tr>      <tr>        <td><input type="number" id="wavelengthh2" value="1560" min="0" oninput="calculateQ(2)"></td>        <td><input type="number" id="ngg2" value="4.4" min="0" step="0.1" oninput="calculateQ(2)"></td>        <td><input type="number" id="alpha2" value="0.1" min="0" step="0.01" oninput="calculateQ(2)"></td>        <td><input type="number" id="radiuss2" value="120" min="0" oninput="calculateQ(2)"></td>        <td><input type="number" id="r1_2" value="0.8" min="0" max="1" step="0.01" oninput="calculateQ(2)"></td>        <td><input type="number" id="r2_2" value="0.9" min="0" max="1" step="0.01" oninput="calculateQ(2)"></td>        <td id="q_2">N/A</td>        <td id="finesse_2">N/A</td>      </tr>      <tr>        <td><input type="number" id="wavelengthh3" value="1570" min="0" oninput="calculateQ(3)"></td>        <td><input type="number" id="ngg3" value="4.4" min="0" step="0.1" oninput="calculateQ(3)"></td>        <td><input type="number" id="alpha3" value="0.1" min="0" step="0.01" oninput="calculateQ(3)"></td>        <td><input type="number" id="radiuss3" value="110" min="0" oninput="calculateQ(3)"></td>        <td><input type="number" id="r1_3" value="0.8" min="0" max="1" step="0.01" oninput="calculateQ(3)"></td>        <td><input type="number" id="r2_3" value="0.9" min="0" max="1" step="0.01" oninput="calculateQ(3)"></td>        <td id="q_3">N/A</td>        <td id="finesse_3">N/A</td>      </tr>      <tr>        <td><input type="number" id="wavelengthh4" value="1310" min="0" oninput="calculateQ(4)"></td>        <td><input type="number" id="ngg4" value="4.4" min="0" step="0.1" oninput="calculateQ(4)"></td>        <td><input type="number" id="alpha4" value="0.1" min="0" step="0.01" oninput="calculateQ(4)"></td>        <td><input type="number" id="radiuss4" value="120" min="0" oninput="calculateQ(4)"></td>        <td><input type="number" id="r1_4" value="0.7" min="0" max="1" step="0.01" oninput="calculateQ(4)"></td>        <td><input type="number" id="r2_4" value="0.8" min="0" max="1" step="0.01" oninput="calculateQ(4)"></td>        <td id="q_4">N/A</td>        <td id="finesse_4">N/A</td>      </tr>      <tr>        <td><input type="number" id="wavelengthh5" value="1530" min="0" oninput="calculateQ(5)"></td>        <td><input type="number" id="ngg5" value="4.4" min="0" step="0.1" oninput="calculateQ(5)"></td>        <td><input type="number" id="alpha5" value="0.1" min="0" step="0.01" oninput="calculateQ(5)"></td>        <td><input type="number" id="radiuss5" value="100" min="0" oninput="calculateQ(5)"></td>        <td><input type="number" id="r1_5" value="0.8" min="0" max="1" step="0.01" oninput="calculateQ(5)"></td>        <td><input type="number" id="r2_5" value="1" min="0" max="1" step="0.01" oninput="calculateQ(5)"></td>        <td id="q_5">N/A</td>        <td id="finesse_5">N/A</td>      </tr>    </tbody>  </table></div>  <script>  function calculateQ(row) {    // 获取输入值    var wavelength = parseFloat(document.getElementById('wavelengthh' + row).value);    var ng = parseFloat(document.getElementById('ngg' + row).value);    var alpha = parseFloat(document.getElementById('alpha' + row).value);    var radius = parseFloat(document.getElementById('radiuss' + row).value);    var r1 = parseFloat(document.getElementById('r1_' + row).value);    var r2 = parseFloat(document.getElementById('r2_' + row).value);    var L = 2 * Math.PI * radius *1e-6;    var a = Math.sqrt(Math.exp(- 100*alpha * L));    var finesse = Math.PI * Math.sqrt(r1 * r2 * a)/(1 - r1 * r2 * a);    var q = finesse * ng * L/(wavelength * 1e-9);    // 显示结果    document.getElementById('q_' + row).innerText = q.toFixed(2);    document.getElementById('finesse_' + row).innerText = finesse.toFixed(2);  }  // 页面加载时自动计算初始值  window.onload = calculateQ(1);  window.onload = calculateQ(2);  window.onload = calculateQ(3);  window.onload = calculateQ(4);  window.onload = calculateQ(5);  </script>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool, photonics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>损耗换算工具</title>
      <link href="/2024/11/17/sun-hao-huan-suan-gong-ju/"/>
      <url>/2024/11/17/sun-hao-huan-suan-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="1-公式"><a href="#1-公式" class="headerlink" title="1 公式"></a>1 公式</h2><script type="math/tex; mode=display">\beta=\frac{2\pi(n+i\kappa)}\lambda</script><script type="math/tex; mode=display">E=E_0e^{i\beta L}=E_0e^{i\frac{2\pi}\lambda nL}e^{-\frac{2\pi}\lambda \kappa L}</script><p>Define $\alpha[dB/cm]$:</p><script type="math/tex; mode=display">\eta=10^{-\frac{100\alpha}{10}L}</script><p>Solve $\alpha(\kappa)[dB/cm]$:</p><script type="math/tex; mode=display">10^{-\frac{100\alpha}{10}L}=e^{-\frac{4\pi}\lambda \kappa L}</script><script type="math/tex; mode=display">\alpha = \frac{0.2}{ln(10)}\frac{2\pi}{\lambda}\kappa</script><p>Define $\alpha’[1/m]$:</p><script type="math/tex; mode=display">\eta=e^{-\alpha'L}</script><p>Solve $\alpha’(\alpha)[dB/cm]$:</p><script type="math/tex; mode=display">\alpha'=10 \alpha ln(10)</script><h2 id="2-转换器"><a href="#2-转换器" class="headerlink" title="2 转换器"></a>2 转换器</h2><p>  <title>参数转换器</title>  <style>    .table-container {      width: 60%;      margin: 20px auto;      font-family: Arial, sans-serif;    }    .table-title {      text-align: center;      font-size: 20px;      margin-bottom: 10px;    }    table {      width: 100%;      border-collapse: collapse;    }    th, td {      border: 1px solid #ddd;      text-align: center;      padding: 10px;    }    th {      background-color: #f7f7f7;    }    input {      width: 90%;      padding: 5px;      text-align: center;      border: 1px solid #ccc;      border-radius: 4px;    }  </style></p>  <div class="table-container">    <div class="table-title"></div>    <table id="conversionTable" class="display">      <thead>        <tr>          <th>λ(nm)</th>          <th>κ</th>          <th>α(dB/cm)</th>          <th>α'(1/m)</th>        </tr>      </thead>      <tbody>        <tr>          <td><input type="number" class="lambda-input" placeholder="输入 λ(nm)" step="0.01"></td>          <td><input type="number" class="kappa-input" placeholder="输入 κ" step="0.00001"></td>          <td><input type="number" class="alpha-db-input" placeholder="输入 α(dB/cm)" step="0.01"></td>          <td><input type="number" class="alpha-prime-input" placeholder="输入 α'(1/m)" step="0.01"></td>        </tr>        <tr>          <td><input type="number" class="lambda-input" placeholder="输入 λ(nm)" step="0.01"></td>          <td><input type="number" class="kappa-input" placeholder="输入 κ" step="0.00001"></td>          <td><input type="number" class="alpha-db-input" placeholder="输入 α(dB/cm)" step="0.01"></td>          <td><input type="number" class="alpha-prime-input" placeholder="输入 α'(1/m)" step="0.01"></td>        </tr>        <tr>          <td><input type="number" class="lambda-input" placeholder="输入 λ(nm)" step="0.01"></td>          <td><input type="number" class="kappa-input" placeholder="输入 κ" step="0.00001"></td>          <td><input type="number" class="alpha-db-input" placeholder="输入 α(dB/cm)" step="0.01"></td>          <td><input type="number" class="alpha-prime-input" placeholder="输入 α'(1/m)" step="0.01"></td>        </tr>        <tr>          <td><input type="number" class="lambda-input" placeholder="输入 λ(nm)" step="0.01"></td>          <td><input type="number" class="kappa-input" placeholder="输入 κ" step="0.00001"></td>          <td><input type="number" class="alpha-db-input" placeholder="输入 α(dB/cm)" step="0.01"></td>          <td><input type="number" class="alpha-prime-input" placeholder="输入 α'(1/m)" step="0.01"></td>        </tr>        <tr>          <td><input type="number" class="lambda-input" placeholder="输入 λ(nm)" step="0.01"></td>          <td><input type="number" class="kappa-input" placeholder="输入 κ" step="0.00001"></td>          <td><input type="number" class="alpha-db-input" placeholder="输入 α(dB/cm)" step="0.01"></td>          <td><input type="number" class="alpha-prime-input" placeholder="输入 α'(1/m)" step="0.01"></td>        </tr>      </tbody>    </table>  </div>  <script>    $(document).ready(function () {      const ln10 = Math.log(10);      const factor = 0.2 * 2 * Math.PI / ln10;      function updateValues(row, inputType) {        const lambda = parseFloat(row.find('.lambda-input').val()); // 波长 λ        const kappa = parseFloat(row.find('.kappa-input').val());  // κ        const alphaDb = parseFloat(row.find('.alpha-db-input').val());  // α (dB/cm)        const alphaPrime = parseFloat(row.find('.alpha-prime-input').val()); // α' (1/m)        if (inputType === 'kappa' && !isNaN(kappa) && !isNaN(lambda)) {          const alpha = (factor * kappa / lambda) * 1e9; // 计算 α (dB/cm)          const alphaPrime = 10 * alpha * ln10;         // 计算 α' (1/m)          row.find('.alpha-db-input').val(alpha.toFixed(7));          row.find('.alpha-prime-input').val(alphaPrime.toFixed(7));        } else if (inputType === 'alpha-db' && !isNaN(alphaDb) && !isNaN(lambda)) {          const kappa = (alphaDb * lambda) / (factor * 1e9); // 计算 κ          const alphaPrime = 10 * alphaDb * ln10;           // 计算 α' (1/m)          row.find('.kappa-input').val(kappa.toFixed(7));          row.find('.alpha-prime-input').val(alphaPrime.toFixed(7));        } else if (inputType === 'alpha-prime' && !isNaN(alphaPrime) && !isNaN(lambda)) {          const alphaDb = alphaPrime/10/ln10;             const kappa = (alphaDb * lambda) / (factor * 1e9); // 计算 κ                 row.find('.kappa-input').val(kappa.toFixed(7));          row.find('.alpha-db-input').val(alphaDb.toFixed(7));        } else if (inputType === 'alpha-prime' && !isNaN(alphaPrime)) {          const alpha = alphaPrime / (10 * ln10);           // 计算 α (dB/cm)          row.find('.alpha-db-input').val(alpha.toFixed(7));        } else if (inputType === 'alpha-db' && !isNaN(alphaDb)) {          const alphaPrime = 10 * alphaDb * ln10;                     row.find('.alpha-prime-input').val(alphaPrime.toFixed(7));        } else if (inputType === 'lambda' && !isNaN(lambda)) {          if (!isNaN(kappa)) {            const alpha = (factor * kappa / lambda) * 1e9;            const alphaPrime = 10 * alpha * ln10;            row.find('.alpha-db-input').val(alpha.toFixed(7));            row.find('.alpha-prime-input').val(alphaPrime.toFixed(7));          } else if (!isNaN(alphaDb)) {            const kappa = (alphaDb * lambda) / (factor * 1e9);            row.find('.kappa-input').val(kappa.toFixed(7));          }        }      }      // 监听输入框变化      $('.lambda-input').on('input', function () {        const row = $(this).closest('tr');        updateValues(row, 'lambda');      });      $('.kappa-input').on('input', function () {        const row = $(this).closest('tr');        updateValues(row, 'kappa');      });      $('.alpha-db-input').on('input', function () {        const row = $(this).closest('tr');        updateValues(row, 'alpha-db');      });      $('.alpha-prime-input').on('input', function () {        const row = $(this).closest('tr');        updateValues(row, 'alpha-prime');      });    });  </script>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool, convert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New Focus 1544光电探测器 手册摘录</title>
      <link href="/2024/10/27/new-focus-1544-guang-dian-tan-ce-qi-shou-ce-zhai-lu/"/>
      <url>/2024/10/27/new-focus-1544-guang-dian-tan-ce-qi-shou-ce-zhai-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-光纤带宽计算公式"><a href="#1-光纤带宽计算公式" class="headerlink" title="1 光纤带宽计算公式"></a>1 光纤带宽计算公式</h2><p><img src="https://s2.loli.net/2024/10/27/GranqXmziMswvZO.png" alt=""></p><h2 id="2-连接器带宽"><a href="#2-连接器带宽" class="headerlink" title="2 连接器带宽"></a>2 连接器带宽</h2><p><img src="https://s2.loli.net/2024/10/27/2HUjq8ni4SyDBzT.png" alt=""><br>Wiltron K即2.92 mm，Wiltron V即1.85 mm</p><hr><p>参考：<br><a href="https://baijiahao.baidu.com/s?id=1738309212838303347&amp;wfr=spider&amp;for=pc">一图区分1.85mm/2.4mm/2.92mm/3.5mm/SMA射频接头</a><br><a href="https://zhuanlan.zhihu.com/p/521535803">射频同轴连接器和电缆指南</a></p>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apparatus, datasheet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对频率啁啾的定量理解</title>
      <link href="/2024/09/21/dui-pin-lu-zhou-jiu-de-ding-liang-li-jie/"/>
      <url>/2024/09/21/dui-pin-lu-zhou-jiu-de-ding-liang-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0 简介"></a>0 简介</h2><p>众所周知，在信号路径某点上，信号的时域波形表达式如下:</p><script type="math/tex; mode=display">E_k(t)=\sqrt{I_k(t-t_k)}\exp\{2\pi i[\nu_k(t-t_k)+\beta(t-t_k)^2+\phi_k]\},</script><p>其中$I_k(t)=\exp\{-t^2/2\tau_p^2\}/(\tau_p\sqrt{2\pi})$是强度的时域包络，下图为半高宽$\tau_p=50 ps$的包络：<br><img src="https://s2.loli.net/2024/09/21/3krS9iLTNfKaPCF.jpg" alt=""><br>$\beta$是和频率啁啾有关的量，其量纲为[$1/s^2$]，不难发现可以类比于加速度。实际上，$E_k(t)$的相位项就是人为的泰勒展开。$\varphi(t)=\nu(t-t_k)+\beta(t-t_k)^2+\varphi_k$完全就是匀加速运动中路程表达式的类比：$x = vt+1/2at^2+x_0$，所以$\nu(t) = \nu+2\beta t$，即$\beta$的符号决定$\nu(t)$随时间的增减，进而引出所谓的<strong>正负啁啾</strong>概念。</p><p>然而，有一个值得思考的点是：$v(t) = v+at$可以小于0，即速度方向可以相反，而频率$\nu(t) = \nu+2\beta t$应当总是正的，假如$\beta$足够大使得$\nu(t)$在时间上出现频率0点，那么会怎样？</p><h2 id="1-仿真分析"><a href="#1-仿真分析" class="headerlink" title="1 仿真分析"></a>1 仿真分析</h2><p>由于光频一般都是几百THz的水平，所以1ps内光已经震动了几百次，50ps内线性项震动了近万次，mathematica看不出任何细节，所以这里仿真的光频为0.06THz，这样在±200ps内线性项大概震动20次；另外，由于非线性项为2次，所以$\beta$也要在0.06的基础上除以大约一个仿真时间的数量级以保证mathematica看出细节，这里$\beta$范围先选取为$[-0.001, 0.001]$：<br><img src="https://s2.loli.net/2024/09/21/eGKQR1m9fVCxOIJ.gif" alt="$\nu=0.06$,$\beta∈[-0.001, 0.001]$"></p><p>可以发现，当$\beta$为某一个值时，频率并非我们想的那样随时间单调增加或单调减少。从$\varphi(t)$的图像可以看出频率0点随着$\beta$的变化，这与$E_k(t)$低频项的位移是一致的：<br><img src="https://s2.loli.net/2024/09/21/KZSkwQAI8nXOJUv.gif" alt="$\nu=0.06$,$\beta∈[-0.001, 0.001]$"></p><p>我们再把$\beta$范围缩小为$[-0.0001, 0.0001]$进行仿真，可以发现当$\beta$为某一个值时，频率随随时间单调增加或单调减少了，这种情况就符合我们对于<strong>正负啁啾</strong>概念的认知：<br><img src="https://s2.loli.net/2024/09/21/qO2leNaA7u8BhWf.gif" alt="$\nu=0.06$,$\beta∈[-0.0001, 0.0001]$"><br>这也能从$\varphi(t)$的图像进行解释，其斜率总是单调的：<br><img src="https://s2.loli.net/2024/09/21/NVsCSjq3T9kJOtp.gif" alt="$\nu=0.06$,$\beta∈[-0.0001, 0.0001]$"></p><h2 id="2-实际DFB激光器是哪种情况？"><a href="#2-实际DFB激光器是哪种情况？" class="headerlink" title="2 实际DFB激光器是哪种情况？"></a>2 实际DFB激光器是哪种情况？</h2><p>1550 nm光频大约为193THz，$\beta=0.02 /ps^2$，这样的参数带入mathematca就是一团浆糊。所以这里取出时刻片段200~200.01ps,对$tk$进行扫描以看清波形的细节和全貌：<br><img src="https://s2.loli.net/2024/09/21/xYgrC8aWkqycvwf.gif" alt="$\nu=193$,$\beta=0.02$"><br>观察到：频率几乎不随时间变化。我们可以从$\varphi(t)$图像进一步验证我们的观察：<br><img src="https://s2.loli.net/2024/09/21/XkOhEYDZFwtLpA9.gif" alt="$\nu=193$,$\beta∈[-0.1, 0.1]$"><br>可以发现，斜率变化相当小，即频率变化相当小；另外，即使在$\beta=0.1$这种尺度范围内，频率依然是单调的。所以可以推断，实际中一般不会出现频率为0的情况，但是不排除这种情况能够被物理实现。</p><h2 id="参考文献及代码"><a href="#参考文献及代码" class="headerlink" title="参考文献及代码"></a>参考文献及代码</h2><ol><li>Yuan Z L, Lucamarini M, Dynes J F, et al. Interference of short optical pulses from independent gain-switched laser diodes for quantum secure communications[J]. Physical Review Applied, 2014, 2(6): 064006.</li><li><a href="https://www.wolframcloud.com/obj/wya1759991046/Published/chirp.nb">mathematica笔记本链接</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> optics, signal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自由空间量子信道计算工具</title>
      <link href="/2024/09/16/zi-you-kong-jian-liang-zi-xin-dao-ji-suan-gong-ju/"/>
      <url>/2024/09/16/zi-you-kong-jian-liang-zi-xin-dao-ji-suan-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="功率单位转换器"><a href="#功率单位转换器" class="headerlink" title="功率单位转换器"></a>功率单位转换器</h2><div class="conversion-table">  <div class="table-title">功率单位转换器</div>     <table id="powerconverter" class="display">        <thead>            <tr>                <th>功率 (W)</th>                <th>功率 (dBm)</th>            </tr>        </thead>        <tbody>            <tr>                <td><input type="number" id="wattInput" placeholder="Enter power in W" min="0" step="0.01"></td>                <td><input type="number" id="dbmInput" placeholder="Enter power in dBm"></td>            </tr>        </tbody>    </table></div><script>  // Conversion from Watt to dBm  function convertToDbm() {    let watt = parseFloat(document.getElementById("wattInput").value);    if (!isNaN(watt) && watt > 0) {      let dbm = 10 * Math.log10(watt * 1000);      document.getElementById("dbmInput").value = dbm.toFixed(2);    } else {      document.getElementById("dbmInput").value = "";    }  }  // Conversion from dBm to Watt  function convertToWatt() {    let dbm = parseFloat(document.getElementById("dbmInput").value);    if (!isNaN(dbm)) {      let watt = Math.pow(10, dbm / 10) / 1000;      document.getElementById("wattInput").value = watt.toFixed(9);    } else {      document.getElementById("wattInput").value = "";    }  }  // Add listeners to detect input changes  function addInputListeners() {    document.getElementById("wattInput").addEventListener("input", convertToDbm);    document.getElementById("dbmInput").addEventListener("input", convertToWatt);  }  // Initialization function to set default values (if needed)  function initializeInputs() {    // Optional: Set a default value (initialization)    document.getElementById("wattInput").value = "1"; // Default 1 W    convertToDbm(); // Convert the default watt to dBm on load  }  // Run the initialization and add listeners when the page loads  document.addEventListener("DOMContentLoaded", function() {    initializeInputs(); // Initialize input values    addInputListeners(); // Add event listeners for real-time conversion  });</script><div class="conversion-table">  <div class="table-title">透射率单位转换器</div>     <table id="powerconverter" class="display">        <thead>            <tr>                <th>透射率/损耗</th>                <th>透射率/损耗 (dB)</th>            </tr>        </thead>        <tbody>            <tr>                <td><input type="number" id="transinput" placeholder="Enter power in W" min="0" max="1" step="0.01"></td>                <td><input type="number" id="dbInput" placeholder="Enter power in dBm" max="0"></td>            </tr>        </tbody>    </table></div><script>  // Conversion from Watt to dBm  function transconvertToDbm() {    let watt = parseFloat(document.getElementById("transinput").value);    if (!isNaN(watt) && watt > 0) {      let dbm = 10 * Math.log10(watt);      document.getElementById("dbInput").value = dbm.toFixed(2);    } else {      document.getElementById("dbInput").value = "";    }  }  // Conversion from dBm to Watt  function transconvertToWatt() {    let dbm = parseFloat(document.getElementById("dbInput").value);    if (!isNaN(dbm)) {      let watt = Math.pow(10, dbm / 10);      document.getElementById("transinput").value = watt.toFixed(9);    } else {      document.getElementById("transinput").value = "";    }  }  // Add listeners to detect input changes  function transaddInputListeners() {    document.getElementById("transinput").addEventListener("input", transconvertToDbm);    document.getElementById("dbInput").addEventListener("input", transconvertToWatt);  }  // Initialization function to set default values (if needed)  function transinitializeInputs() {    // Optional: Set a default value (initialization)    document.getElementById("transinput").value = "1"; // Default 1 W    transconvertToDbm(); // Convert the default watt to dBm on load  }  // Run the initialization and add listeners when the page loads  document.addEventListener("DOMContentLoaded", function() {    transinitializeInputs(); // Initialize input values    transaddInputListeners(); // Add event listeners for real-time conversion  });</script><hr><h2 id="光源功率计算器"><a href="#光源功率计算器" class="headerlink" title="光源功率计算器"></a>光源功率计算器</h2><div class="table-container">    <div class="table-title">光源功率计算器</div>    <table id="powerCalculationTable" class="display">        <thead>            <tr>                <th>参数</th>                <th>值</th>            </tr>        </thead>        <tbody>            <tr>                <td>波长 (nm)</td>                <td><input type="number" id="wavelength" value="1550.92" step="0.01"></td>            </tr>            <tr id="photonfrequencyRow">                <td>光子频率 (THz)</td>                <td id="photonfrequency">1.2808177450e-19</td>            </tr>            <tr id="photonEnergyRow">                <td>单光子能量 (J)</td>                <td id="photonEnergy">1.2808177450e-19</td>            </tr>            <tr>                <td>重频 (MHz)</td>                <td><input type="number" id="frequency" value="1250" step="1"></td>            </tr>            <tr>                <td>信号态平均光子数</td>                <td><input type="number" id="signalPhoton" value="0.6" step="0.01"></td>            </tr>            <tr>                <td>信号态占比</td>                <td><input type="number" id="signalRatio" value="0.5" step="0.01"></td>            </tr>            <tr>                <td>诱骗态1平均光子数</td>                <td><input type="number" id="decoy1Photon" value="0.3" step="0.01"></td>            </tr>            <tr>                <td>诱骗态1占比</td>                <td><input type="number" id="decoy1Ratio" value="0.25" step="0.01"></td>            </tr>            <tr>                <td>诱骗态2平均光子数</td>                <td><input type="number" id="decoy2Photon" value="0.0001" step="0.0001"></td>            </tr>            <tr id="decoy2RatioRow">                <td>诱骗态2占比</td>                <td id="decoy2Ratio">0.25</td>            </tr>            <tr id="averagePhotonPulseRow">                <td>平均每脉冲光子数</td>                <td id="averagePhotonPulse">0.375025</td>            </tr>            <tr id="sourcePowerRow">                <td>光源功率 (nW)</td>                <td id="sourcePower">N/A</td>            </tr>            <tr id="sourcePowerdBmRow">                <td>光源功率 (dBm)</td>                <td id="sourcePowerdBm">N/A</td>            </tr>                    </tbody>    </table></div><script>function calculateSinglePhotonEnergy() {    var wavelength = parseFloat(document.getElementById('wavelength').value);    var SinglePhotonEnergy = 6.62607015 * 1e-34 * 299792458/(wavelength*1e-9);    var scientificNotation = SinglePhotonEnergy.toExponential(10);    var photonfrequency  = 299792458/(wavelength * 1e-9)/1e12;    document.getElementById('photonEnergy').innerText = scientificNotation;    document.getElementById('photonfrequency').innerText = photonfrequency.toFixed(4);    return scientificNotation;}function calculatedecoy2Ratio() {    var signalRatio = parseFloat(document.getElementById('signalRatio').value);    var decoy1Ratio = parseFloat(document.getElementById('decoy1Ratio').value);    var decoy2Ratio = 1 - signalRatio - decoy1Ratio;    document.getElementById('decoy2Ratio').innerText = decoy2Ratio.toFixed(2);    return decoy2Ratio;}function calculateAveragePhotonPulse() {    var signalPhoton = parseFloat(document.getElementById('signalPhoton').value);    var signalRatio = parseFloat(document.getElementById('signalRatio').value);    var decoy1Photon = parseFloat(document.getElementById('decoy1Photon').value);    var decoy1Ratio = parseFloat(document.getElementById('decoy1Ratio').value);    var decoy2Photon = parseFloat(document.getElementById('decoy2Photon').value);    var decoy2Ratio = calculatedecoy2Ratio();    // 计算平均每脉冲光子数    var averagePhotonPulse = (signalPhoton * signalRatio) + (decoy1Photon * decoy1Ratio) + (decoy2Photon * decoy2Ratio);    document.getElementById('averagePhotonPulse').innerText = averagePhotonPulse.toFixed(6);    return averagePhotonPulse;}function calculateSourcePower() {    var frequency = parseFloat(document.getElementById('frequency').value);    var photonEnergy = calculateSinglePhotonEnergy();    var averagePhotonPulse = calculateAveragePhotonPulse();    // 计算光源功率    var sourcePower = frequency * 1e6 * photonEnergy * averagePhotonPulse * 1e9;  // 转换为nW    var sourcePowerdBm = 10 * Math.log10(sourcePower * 1e-9 * 1e3);  // 转换为dBm    document.getElementById('sourcePower').innerText = sourcePower.toFixed(6);    document.getElementById('sourcePowerdBm').innerText = sourcePowerdBm.toFixed(4);}// 监听所有输入框的输入事件，实时更新计算结果document.getElementById('wavelength').addEventListener('input', calculateSourcePower);document.getElementById('frequency').addEventListener('input', calculateSourcePower);document.getElementById('signalPhoton').addEventListener('input', calculateSourcePower);document.getElementById('signalRatio').addEventListener('input', calculateSourcePower);document.getElementById('decoy1Photon').addEventListener('input', calculateSourcePower);document.getElementById('decoy1Ratio').addEventListener('input', calculateSourcePower);document.getElementById('decoy2Photon').addEventListener('input', calculateSourcePower);document.getElementById('frequency').addEventListener('input', calculateSourcePower);// 初始化计算calculateSourcePower();</script><hr><h2 id="空间损耗-AB镜间损耗计算器"><a href="#空间损耗-AB镜间损耗计算器" class="headerlink" title="空间损耗/AB镜间损耗计算器"></a>空间损耗/AB镜间损耗计算器</h2><div class="table-container">    <div class="table-title">空间损耗/AB镜间损耗计算器</div>    <table id="lossCalculationTable" class="display">        <thead>            <tr>                <th>参数</th>                <th>值</th>            </tr>        </thead>        <tbody>            <tr>                <td>发散角 (urad)</td>                <td><input type="number" id="divergenceAngle" value="35" min="0" max="100000" step="1"></td>            </tr>            <tr>                <td>通信距离 (km)</td>                <td><input type="number" id="distance" value="30" min="0"></td>            </tr>            <tr>                <td>接收口径 (m)</td>                <td><input type="number" id="receiverDiameter" value="0.28" step="0.02"></td>            </tr>            <tr id="spaceLossRow">                <td>空间损耗</td>                <td id="spaceLoss">0.0711</td>            </tr>            <tr>                <td>大气损耗</td>                <td><input type="number" id="atmosphericLoss" value="0.25" min="0" max="1" step="0.05"></td>            </tr>            <tr id="ABLossRow">                <td>A镜-B镜损耗</td>                <td id="ABLoss">0.0178</td>            </tr>            <tr id="ABLossdBRow">                <td>A镜-B镜损耗（dB）</td>                <td id="ABLossdB">0.0178</td>            </tr>        </tbody>    </table></div><script>function calculateSpaceLoss() {    // 获取用户输入的值    var divergenceAngle = parseFloat(document.getElementById('divergenceAngle').value);    var distance = parseFloat(document.getElementById('distance').value);    var receiverDiameter = parseFloat(document.getElementById('receiverDiameter').value);    var atmosphericLoss = parseFloat(document.getElementById('atmosphericLoss').value);        // 验证发散角是否在 0 到 1 的范围内    if (atmosphericLoss < 0 || atmosphericLoss > 1) {        alert("大气损耗必须在 0 和 1 之间");        return;    }    // 验证输入是否为有效数字    if (!isNaN(divergenceAngle) && !isNaN(distance) && !isNaN(receiverDiameter) && !isNaN(atmosphericLoss)) {        // 计算空间损耗的公式        if (receiverDiameter <= divergenceAngle * distance / 1000){            var spaceLoss = Math.pow((receiverDiameter / (divergenceAngle * distance / 1000)), 2);        }        else {            var spaceLoss = 1;        }        // 计算A镜-B镜损耗的公式        var ABLoss = spaceLoss * atmosphericLoss;        var ABLossdB = 10 * Math.log10(ABLoss);        // 显示结果        document.getElementById('spaceLoss').innerText = spaceLoss.toFixed(4);        document.getElementById('ABLoss').innerText = ABLoss.toFixed(4);        document.getElementById('ABLossdB').innerText = ABLossdB.toFixed(4);    } else {        document.getElementById('spaceLoss').innerText = 'N/A';        document.getElementById('ABLoss').innerText = 'N/A';        document.getElementById('ABLossdB').innerText = 'N/A';    }}// 监听所有输入框的输入事件，实时更新计算结果document.getElementById('divergenceAngle').addEventListener('input', calculateSpaceLoss);document.getElementById('distance').addEventListener('input', calculateSpaceLoss);document.getElementById('receiverDiameter').addEventListener('input', calculateSpaceLoss);document.getElementById('atmosphericLoss').addEventListener('input', calculateSpaceLoss);calculateSpaceLoss();</script><hr><h2 id="B-后光路效率计算器"><a href="#B-后光路效率计算器" class="headerlink" title="B 后光路效率计算器"></a>B 后光路效率计算器</h2><div class="table-container">    <div class="table-title">B 后光路效率计算器</div>    <table id="efficiencyTable" class="display">        <thead>            <tr>                <th>参数</th>                <th>值</th>            </tr>        </thead>        <tbody>            <tr>                <td>接收光学效率</td>                <td><input type="number" id="efficiency1" value="0.6" step="0.01" min="0" max="1"></td>            </tr>            <tr>                <td>接收耦合效率</td>                <td><input type="number" id="efficiency2" value="0.6" step="0.01" min="0" max="1"></td>            </tr>            <tr>                <td>滤波效率</td>                <td><input type="number" id="efficiency3" value="1" step="0.01" min="0" max="1"></td>            </tr>            <tr>                <td>探测器效率</td>                <td><input type="number" id="efficiency4" value="0.2" step="0.01" min="0" max="1"></td>            </tr>            <tr>                <td>门控效率</td>                <td><input type="number" id="efficiency5" value="0.8" step="0.01" min="0" max="1"></td>            </tr>            <tr id="totalEfficiencyRow">                <td>B 后光路总效率</td>                <td id="totalEfficiency">N/A</td>            </tr>            <tr id="totalEfficiencydBRow">                <td>B 后光路总效率（dB）</td>                <td id="totalEfficiencydB">N/A</td>            </tr>                   </tbody>    </table></div><script>function calculateTotalEfficiency() {    // 获取用户输入的效率值    var efficiency1 = parseFloat(document.getElementById('efficiency1').value);    var efficiency2 = parseFloat(document.getElementById('efficiency2').value);    var efficiency3 = parseFloat(document.getElementById('efficiency3').value);    var efficiency4 = parseFloat(document.getElementById('efficiency4').value);    var efficiency5 = parseFloat(document.getElementById('efficiency5').value);    // 验证输入是否为有效数字    if (!isNaN(efficiency1) && !isNaN(efficiency2) && !isNaN(efficiency3) &&        !isNaN(efficiency4) && !isNaN(efficiency5)) {        // 计算 B 后光路总效率        var totalEfficiency = efficiency1 * efficiency2 * efficiency3 * efficiency4 * efficiency5;        var totalEfficiencydB = 10 * Math.log10(totalEfficiency);        // 显示结果        document.getElementById('totalEfficiency').innerText = totalEfficiency.toFixed(4);        document.getElementById('totalEfficiencydB').innerText = totalEfficiencydB.toFixed(2);    } else {        document.getElementById('totalEfficiency').innerText = 'N/A';        document.getElementById('totalEfficiencydB').innerText = 'N/A';    }}// 监听所有输入框的输入事件，实时更新计算结果document.getElementById('efficiency1').addEventListener('input', calculateTotalEfficiency);document.getElementById('efficiency2').addEventListener('input', calculateTotalEfficiency);document.getElementById('efficiency3').addEventListener('input', calculateTotalEfficiency);document.getElementById('efficiency4').addEventListener('input', calculateTotalEfficiency);document.getElementById('efficiency5').addEventListener('input', calculateTotalEfficiency);// 初始化计算calculateTotalEfficiency();</script><hr><h2 id="B-QBER计算器"><a href="#B-QBER计算器" class="headerlink" title="B QBER计算器"></a>B QBER计算器</h2><div class="table-container">    <div class="table-title">B QBER计算器</div>    <table id="eventTable" class="display">        <thead>            <tr>                <th>参数</th>                <th>值</th>            </tr>        </thead>        <tbody>            <tr>                <td>重频 (MHz)</td>                <td><input type="number" id="frequency1" value="1250" step="1" min="0"></td>            </tr>            <tr>                <td>信号态平均光子数</td>                <td><input type="number" id="avgPhotonCount" value="0.6" step="0.01" min="0"></td>            </tr>            <tr>                <td>信号态占比</td>                <td><input type="number" id="signalRatio1" value="0.5" step="0.01" min="0" max="1"></td>            </tr>            <tr>                <td>总损耗</td>                <td><input type="number" id="totalLoss" value="0.01" step="0.001" min="0" max="1"></td>            </tr>            <tr id="eventCountRow">                <td>B 探测到信号态事件数（Hz）</td>                <td id="eventCount">N/A</td>            </tr>            <tr>                <td>B 4路探测器噪声（Hz）</td>                <td><input type="number" id="detnoise" value="800" step="1" min="0"></td>            </tr>            <tr>                <td>B 环境噪声（Hz）</td>                <td><input type="number" id="envirnoise" value="1000" step="1" min="0"></td>            </tr>            <tr id="totalnoiseRow">                <td>B 总噪声（Hz）</td>                <td id="totalnoise">N/A</td>            </tr>            <tr id="noiseBERRow">                <td>噪声误码率（B 总噪声引入的错误/B 总计数）</td>                <td id="noiseBER">N/A</td>            </tr>            <tr>                <td>偏振误码率（B 信号态偏振误码数/B 信号态事件数）</td>                <td><input type="number" id="PBER" value="0.005" step="0.001" min="0" max="1"></td>            </tr>            <tr id="QBERRow">                <td>总误码率</td>                <td id="QBER">N/A</td>            </tr>        </tbody>    </table></div><script>function calculateQBER() {    // 获取用户输入的效率值    var frequency1 = parseFloat(document.getElementById('frequency1').value);    var avgPhotonCount = parseFloat(document.getElementById('avgPhotonCount').value);    var signalRatio1 = parseFloat(document.getElementById('signalRatio1').value);    var totalLoss = parseFloat(document.getElementById('totalLoss').value);    var detnoise = parseFloat(document.getElementById('detnoise').value);    var envirnoise = parseFloat(document.getElementById('envirnoise').value);    var PBER = parseFloat(document.getElementById('PBER').value);    // 验证输入是否为有效数字    if (!isNaN(frequency1) && !isNaN(avgPhotonCount) && !isNaN(signalRatio1) && !isNaN(totalLoss) && !isNaN(detnoise) && !isNaN(envirnoise) &&        !isNaN(PBER)) {        // 计算 B 后光路总效率        var eventCount = frequency1 * 1e6 * signalRatio1 * (1 - Math.exp(-totalLoss*avgPhotonCount));        var totalnoise = detnoise + envirnoise;        var noiseBER = totalnoise/4/2/(totalnoise + eventCount);        var QBER = (totalnoise/4/2 + PBER * eventCount)/(totalnoise + eventCount);        // 显示结果        document.getElementById('eventCount').innerText = eventCount.toFixed(0);        document.getElementById('totalnoise').innerText = totalnoise.toFixed(0);        document.getElementById('noiseBER').innerText = noiseBER.toFixed(6);        document.getElementById('QBER').innerText = QBER.toFixed(6);    } else {        document.getElementById('eventCount').innerText = 'N/A';        document.getElementById('totalnoise').innerText = 'N/A';        document.getElementById('noiseBER').innerText = 'N/A';        document.getElementById('QBER').innerText = 'N/A';    }}// 监听所有输入框的输入事件，实时更新计算结果document.getElementById('frequency1').addEventListener('input', calculateQBER);document.getElementById('avgPhotonCount').addEventListener('input', calculateQBER);document.getElementById('signalRatio1').addEventListener('input', calculateQBER);document.getElementById('totalLoss').addEventListener('input', calculateQBER);document.getElementById('detnoise').addEventListener('input', calculateQBER);document.getElementById('envirnoise').addEventListener('input', calculateQBER);document.getElementById('PBER').addEventListener('input', calculateQBER);// 初始化计算calculateQBER();</script><style>.table-container {    padding: 20px;    margin: 0 auto; /* 表格容器居中 */    text-align: left; /* 让内容居中 */}.table-title {    font-size: 20px;    font-weight: bold;    text-align: left;}table {    table-layout: fixed; /* 固定表格布局 */    width: 100%; /* 设置表格宽度 */    border-collapse: collapse;    margin: 0 auto; /* 表格居中 */}th, td {    border: 1px solid #ddd;    padding: 10px;    text-align: center;    width: 65%;}#photonEnergyRow, #decoy2RatioRow, #averagePhotonPulseRow, #photonfrequencyRow,#sourcePowerRow, #sourcePowerdBmRow, #spaceLossRow, #ABLossRow,#ABLossdBRow,#totalEfficiencyRow, #totalEfficiencydBRow,#eventCountRow, #totalnoiseRow, #noiseBERRow, #QBERRow {    background-color: skyblue;}</style>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool, QKD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>角度弧度换算工具</title>
      <link href="/2024/09/16/jiao-du-hu-du-huan-suan-gong-ju/"/>
      <url>/2024/09/16/jiao-du-hu-du-huan-suan-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="角度⇔弧度转换器"><a href="#角度⇔弧度转换器" class="headerlink" title="角度⇔弧度转换器"></a>角度⇔弧度转换器</h2><div class="table-container">    <div class="table-title">角度⇔弧度转换器</div>    <table id="conversionTable" class="display">        <thead>            <tr>                <th>角度 (°)</th>                <th>弧度 (rad)</th>            </tr>        </thead>        <tbody>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>            <tr>                <td><input type="number" class="angle-input" placeholder="输入角度"></td>                <td><input type="number" class="radian-input" placeholder="输入弧度"></td>            </tr>        </tbody>    </table></div><style>.table-container {    padding: 20px;}.table-title {    font-size: 20px;    font-weight: bold;    text-align: left;}table {    border-collapse: collapse;    border-radius: 10px;    width: 100%;}th, td {    border: 1px solid #ddd;    padding: 10px;    text-align: center;    width: 50%;}</style><script>$(document).ready(function() {    // 角度转换为弧度的函数    function toRadians(angle) {        return (angle * Math.PI / 180).toFixed(7);    }    // 弧度转换为角度的函数    function toDegrees(radian) {        return (radian * 180 / Math.PI).toFixed(5);    }    // 监听角度输入框的输入事件，实时转换为弧度    $('.angle-input').on('input', function() {        var angleValue = parseFloat($(this).val());        if (!isNaN(angleValue)) {            var radianValue = toRadians(angleValue);            $(this).closest('tr').find('.radian-input').val(radianValue);        } else {            $(this).closest('tr').find('.radian-input').val('');        }    });    // 监听弧度输入框的输入事件，实时转换为角度    $('.radian-input').on('input', function() {        var radianValue = parseFloat($(this).val());        if (!isNaN(radianValue)) {            var angleValue = toDegrees(radianValue);            $(this).closest('tr').find('.angle-input').val(angleValue);        } else {            $(this).closest('tr').find('.angle-input').val('');        }    });});</script>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool, convert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河边风光</title>
      <link href="/2024/08/26/he-bian-feng-guang/"/>
      <url>/2024/08/26/he-bian-feng-guang/</url>
      
        <content type="html"><![CDATA[<h2 id="20240825"><a href="#20240825" class="headerlink" title="20240825"></a>20240825</h2><p><img src="https://s2.loli.net/2024/08/26/XuwYdfnb6DmsORz.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/5lAO4YUviqGXSrx.jpg" alt=""></p><h2 id="20220628"><a href="#20220628" class="headerlink" title="20220628"></a>20220628</h2><p><img src="https://s2.loli.net/2024/08/26/Pz5SC7qoawYky9r.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/2ZtopRHqO6zsAEl.jpg" alt=""></p><h2 id="20210831"><a href="#20210831" class="headerlink" title="20210831"></a>20210831</h2><p><img src="https://s2.loli.net/2024/08/26/3XkPQ1N65DMVAEH.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/azZHe3huqfpQBvw.jpg" alt=""></p><h2 id="20200822"><a href="#20200822" class="headerlink" title="20200822"></a>20200822</h2><p><img src="https://s2.loli.net/2024/08/26/lMzjiGQ4VrdqPgb.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/ypNm3YCHLirS7UW.jpg" alt=""></p><h2 id="20190821"><a href="#20190821" class="headerlink" title="20190821"></a>20190821</h2><p><img src="https://s2.loli.net/2024/08/26/8nqRFcKMtCYy56X.jpg" alt=""><br><img src="https://s2.loli.net/2024/08/26/m5FYEHWNLIi6wMq.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> vision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary, landscape </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thorlabs PAX1000不准直会发生的现象及原因探寻</title>
      <link href="/2024/08/21/thorlabs-pax1000-bu-zhun-zhi-hui-fa-sheng-de-xian-xiang-ji-yuan-yin-tan-xun/"/>
      <url>/2024/08/21/thorlabs-pax1000-bu-zhun-zhi-hui-fa-sheng-de-xian-xiang-ji-yuan-yin-tan-xun/</url>
      
        <content type="html"><![CDATA[<h2 id="0-现象"><a href="#0-现象" class="headerlink" title="0 现象"></a>0 现象</h2><ol><li><p>前几天使用matlab visa库控制PAX1000测试光芯片偏振调制时，发现偏振输出会在邦加球上两条调制曲线之间无规律横跳：<br><img src="https://s2.loli.net/2024/08/21/WomscDVfxU8qrlH.png" alt=""><br>固定某个调制电压，发现偏振态会在两个邦加球两点之间无规律横跳。</p></li><li><p>为了排除光芯片的原因，我直接向PAX1000打入单模耦合输入的偏振光（正确做法是拿保偏接，但是单模短时间内偏振变化不会太大），记录120s内visa以1Hz速率传输的数据和120s中某一时刻PAX1000自带软件的截图，可以发现：</p></li></ol><ul><li>使用matlab visa库读取的方位角(Azimuth θ)、椭圆率角(Ellipticity η)会横跳；</li><li>使用PAX1000自带软件测试不会横跳；</li><li>PAX1000自带软件数据在横跳数据之间，但不是正中间。</li></ul><p><img src="https://s2.loli.net/2024/08/21/ROHPFrzL8yIShW4.jpg" alt="visa传输数据"><br><img src="https://s2.loli.net/2024/08/21/MrA7OFbKNexI5LE.png" alt="PAX1000软件数据"></p><h2 id="1-朔源"><a href="#1-朔源" class="headerlink" title="1 朔源"></a>1 朔源</h2><p>查阅手册发现原因可能是前些天准直器松动后我重新固定了，但是没有准直。而没有准直会出现以下问题，即引入奇数次谐波：<br><em>“The angular alignment is critical for another reason: As explained in the section Rotating Waveplate Technique , the photo current is analyzed by a Fast Fourier Transformation and ideally<br>consists only of even-numbered components (harmonics). If the beam hits the waveplate not<br>exactly perpendicular, unwanted odd-numbered harmonics will appear in the photo current. The<br>same happens, if the incident beam consists reflected from the inner surface of the hollow shaft<br>light components. These unwanted components have a significant impact on the measurement<br>accuracy. The Alignment Assistance tool can be used to align the beam, which will minimize<br>the contribution from unwanted components.”</em></p><p>于是我手动准直了一下PAX1000，发现数据反复横跳的现象确实消失了，且visa读出数据与软件数据完全吻合。然而，为什么不准直会引入奇数次谐振？为了解释这个问题，我们首先要知道PAX1000的工作原理。<br><img src="https://s2.loli.net/2024/08/21/ALkfWGJZsV4NHmo.png" alt="FOURIER ANALYSIS USING A ROTATING QUARTER-WAVE RETARDER"><br>由于PAX1000使用了上世纪的旋转波片技术，所以随便翻一本经典的偏振书籍就能找到解释：不同的偏振光经过旋转1/4波片及固定极化片，再经过光电探测可以得到随时间变化的光电流</p><script type="math/tex; mode=display">I(\theta)=\frac{1}{2}\left[\left(S_{0}+\frac{S_{1}}{2}\right)+\frac{S_{1}}{2}\cos4\theta+\frac{S_{2}}{2}\sin4\theta-S_{3}\sin2\theta\right]\\=\frac{1}{2}[A-B\sin2\omega t+C\cos4\omega t+D\sin4\omega t]</script><p>这是傅里叶展开，于是可以通过积分算系数，再解方程求偏振参数：</p><script type="math/tex; mode=display">\begin{aligned}&A=\frac1\pi\int_0^{2\pi}I(\theta) d\theta\\&B=\frac2\pi\int_0^{2\pi}I(\theta)\sin2\theta d\theta\\&C=\frac2\pi\int_0^{2\pi}I(\theta)\cos4\theta d\theta\\&D=\frac2\pi\int_0^{2\pi}I(\theta)\sin4\theta d\theta\end{aligned}</script><p>由于现实中没有积分器，于是采样并求和，就得到了PAX1000的数据处理方法：</p><script type="math/tex; mode=display">\begin{aligned}A & =\frac{2}{N} \sum_{n=1}^{N} I\left(n \theta_{j}\right) \\B & =\frac{4}{N} \sum_{n=1}^{N} I\left(n \theta_{j}\right) \sin 2 n \theta_{j} \\C & =\frac{4}{N} \sum_{n=1}^{N} I\left(n \theta_{j}\right) \cos 4 n \theta_{j} \\D & =\frac{4}{N} \sum_{n=1}^{N} I\left(n \theta_{j}\right) \sin 4 n \theta_{j}\end{aligned}</script><p>这个表达式里面确实只有偶数项，那奇数项会从哪里引入呢？另外，为什么只在两个值之间横跳？再仔细翻阅手册，可以发现这么一段话：<br><em>“The photo current measured during this half turn is analyzed by a Fast Fourier Transformation (FFT). By default, the FFT “splits” the data into 512 measurement points (ADC values).”</em><br>好家伙，难道用visa时我只用了半圈去计算？于是我试了下将软件调成以半圈为周期计算，结果还真是反复横跳，且相当规律：<br><img src="https://s2.loli.net/2024/08/21/Mgs3olvm2ZYaUiz.png" alt=""><br>这样一来，我们要解决的问题就变成了：<br><strong>当没准直时，且使用半圈去计算时，为什么偏振结果会跳变？</strong></p><h2 id="2-原因"><a href="#2-原因" class="headerlink" title="2 原因"></a>2 原因</h2><p>当没有准直时，光线即使斜入射波片，也不会造成前半圈和后半圈结果不同，所以不对称很可能来源于波片瑕疵。然而，假如确实是由波片不完美导致的，由于旋转过程中光束落点处波片厚度不同，那么准直入射的情况也应该显现出偏振跳变。实际情况是，只有未准直的光束显现出了偏振跳变，所以肯定不是由于波片瑕疵导致的。</p><p>在查阅文献后，我找到了可能的问题来源：实际情况中，波片平面与其旋转轴肯定不是完美垂直，而是存在一个角度”Wobble”，而当波片高速转动时，由于离心力这个角度放大。<br><img src="https://s2.loli.net/2024/08/24/TELMOl4NrndsxGf.png" alt=""></p><p>为了说明”Wobble”可能导致偏振跳变的情况，我们分别考察准直和不准直的两种情况：</p><ol><li><p>准直时，在波片旋转的过程中，入射光线和主轴的夹角不会发生任何改变。这里用mathematica做了一个动画演示，其中蓝色向量代表入射光线，灰色圆盘代表波片，绿线代表波片主轴，红色向量代表波片法向，设置”Wobble”=30°。另外，我画出了旋转过程中入射光线和主轴的夹角。可以发现，在波片旋转过程中夹角不发生任何改变：<br><img src="https://s2.loli.net/2024/08/24/Krf4chJQsN5eZyC.gif" alt=""><br><img src="https://s2.loli.net/2024/08/24/naWjO94UV7oFbAu.jpg" alt=""><br>另外，稍微想一下也会发现光束落点也不会影响半圈一致性。</p></li><li><p>不准直时，入射光线和主轴的夹角发现改变，<strong>且有99.9999…%的可能性使半圈对称性“破缺”</strong>。这里同样做了动画演示，配置同上，入射光线偏斜45°。可以发现，在波片旋转中入射光线和主轴的夹角一直在变化，且前半圈和后半圈不具有对称性：<br><img src="https://s2.loli.net/2024/08/24/gF76ZanpXhoWCPN.gif" alt=""><br><img src="https://s2.loli.net/2024/08/24/euv4PGfCcyLYMjI.jpg" alt=""></p></li></ol><p><strong>然而有一种特殊情况不会导致对称性“破缺”</strong>，这种情况几乎不可能发生，这种情况下主轴在旋转时不会于准直入射方向发生夹角的改变，因此等价于光束斜入射”Wobble”=0°的波片。<br><img src="https://s2.loli.net/2024/08/24/o89mFNbqZuvjrQy.gif" alt=""><br><img src="https://s2.loli.net/2024/08/24/zUNAyhmxWaFwSG5.jpg" alt=""></p><h2 id="3-闭环"><a href="#3-闭环" class="headerlink" title="3 闭环"></a>3 闭环</h2><ol><li>没准值时visa偏振跳变是由于没有下发整数圈数据处理的指令。</li><li>准直时用半圈处理数据不会导致偏振跳变。</li><li>理想/非理想情况下(当不存在/存在wobble时)，准直且用用半圈处理数据不会导致偏振跳变。</li><li>理想情况下(当不存在wobble时)，没准直且用用半圈处理数据不会导致偏振跳变。</li><li>非理想情况下(当存在wobble时)，没准直且用用半圈处理数据会导致偏振跳变。</li><li><strong>手册中不准值时引入奇数项的具体含义是：光强中不仅有二次项（半圈）以及四次项（1/4圈）存在了，还引入了一次项（1圈）</strong>。</li></ol><h2 id="参考文献及代码链接"><a href="#参考文献及代码链接" class="headerlink" title="参考文献及代码链接"></a>参考文献及代码链接</h2><ol><li>Williams P A. Rotating-wave-plate Stokes polarimeter for differential group delay measurements of polarization-mode dispersion[J]. Applied optics, 1999, 38(31): 6508-6515.</li><li><a href="https://www.wolframcloud.com/obj/wya1759991046/Published/pax1000simu.nb">mathematica笔记本链接</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apparatus, polarization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>叠层阻抗含义</title>
      <link href="/2024/07/30/die-ceng-zu-kang-han-yi/"/>
      <url>/2024/07/30/die-ceng-zu-kang-han-yi/</url>
      
        <content type="html"><![CDATA[<p>这是一张14层的叠层阻抗表，黄色标注了1-4层的三阶盲埋：<br><img src="https://s2.loli.net/2024/07/30/D9UOSApXMT4EBdj.png" alt=""><br><strong>注：FR4图中写错，FR4 = Fire Resist level4，是一种防火等级，因为PCB需要有主动阻燃性，所以需要FR4材料。FR4一般都指core(芯板)中间黄色部分，其厚度为规定值，以core形态成品售往PCB工厂，所以FR4一般也指core。PP(prepreg，又称半固化片)也属于FR4，只不过部分固化，PCB 制造商使用它来将蚀刻芯粘合在一起。可参考：<a href="https://electronics.stackexchange.com/questions/356063/what-exactly-is-prepreg-and-core-in-a-pcb">What exactly is prepreg and core in a PCB?</a></strong></p><p>与阻抗计算工具的结果吻合：<br><img src="https://s2.loli.net/2024/07/30/JCwgvN4IMdceSlb.png" alt=""><br><img src="https://s2.loli.net/2024/07/30/xoYAMfbRiZKE2pu.png" alt=""></p><hr><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/512495251">PCB板材的基础知识</a><br><a href="https://baijiahao.baidu.com/s?id=1787683941435650876&amp;wfr=spider&amp;for=pc">高速PCB的铜箔选用指南</a><br><a href="https://www.sunshinepcb.com/news/knowledge/81.html">PCB叠层设计指南 | 从材料选型到叠构设计</a><br><a href="https://www.protoexpress.com/tools/pcb-impedance-calculator/">Impedance Calculator</a><br>附12层叠层阻抗表：<br><img src="https://s2.loli.net/2024/08/19/ShYKyzBtGqRonud.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electronic, PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project · JZ 存储器备忘录</title>
      <link href="/2024/07/29/project-jz-cun-chu-qi-bei-wang-lu/"/>
      <url>/2024/07/29/project-jz-cun-chu-qi-bei-wang-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="0-动机"><a href="#0-动机" class="headerlink" title="0 动机"></a>0 动机</h2><p>Datasheet太多了，点开文件夹查找过于麻烦。作为记性不好又懒得一匹的包工头，不需要动脑写逻辑，只需要了解关键内容。因此摘录sheet要点并加上芯片架构层面的内容和思考，不包含时序和芯片自带功能（例如NAND、MRAM的ECC）的解读，作为一个快捷的备忘录。</p><h2 id="1-DDR2"><a href="#1-DDR2" class="headerlink" title="1 DDR2"></a>1 DDR2</h2><ul><li><p>型号：ISSI(芯成 · 美) IS43DR16128C<br>容量：2Gb = 128M$\times$16b = 8(banks)$\times$16M$\times$16b；<br>位宽：16b<br><img src="https://s2.loli.net/2024/07/29/VRjSW17Zmr9sGYg.png" alt=""><br>速率等ORDER INFO：<br><img src="https://s2.loli.net/2024/07/29/HA2tI3F4SPLQrNz.png" alt=""></p></li><li><p>特征参数<br><img src="https://s2.loli.net/2024/07/29/8ynSs1dVxYEO2jW.png" alt=""></p></li><li><p>架构<br><img src="https://s2.loli.net/2024/07/29/Jh42Vz1vXlWRQOr.png" alt=""></p></li><li><p>管脚<br><img src="https://s2.loli.net/2024/07/29/tmMiAjwrGXa3obW.png" alt=""><br><img src="https://s2.loli.net/2024/07/29/ohdg3EtqW29fGaD.png" alt=""><br>管脚特征：<br>没有读使能信号，读使能是通过拉高写使能。<br>DDR2不像NAND FLASH一样复用IO可能是因为要求高速。<br>DM掩码某些数据位，而DQS有效化某些数据时刻，作用不一样。</p></li></ul><h2 id="2-NAND-FLASH"><a href="#2-NAND-FLASH" class="headerlink" title="2 NAND FLASH"></a>2 NAND FLASH</h2><ul><li><p>型号：MICRON(美光 · 美) MT29F128G08AMCABH2<br>容量：128Gb = 16384(块)$\times$128(页)$\times$8640B；<br>位宽：8b<br><img src="https://s2.loli.net/2024/07/29/xcMjmuVCUGFgHfk.png" alt=""></p></li><li><p>特征参数<br><img src="https://s2.loli.net/2024/07/29/ujJgxMwW1hY2RU7.png" alt=""><br>注意，NAND手册一般不会给出工作在同步模式下的时钟频率。</p></li><li><p>架构<br><img src="https://s2.loli.net/2024/07/29/8kyEAR1xzLZG6Ma.png" alt=""><br><img src="https://s2.loli.net/2024/07/29/lNm5boGgRK1fX6h.png" alt=""><br>MT29F128G08AMCABH2有4个LUN。</p></li><li><p>管脚<br><img src="https://s2.loli.net/2024/07/29/DoIMucBGz98Leth.png" alt=""><br>为什么这样分配管脚：<br><strong><em>比如命令锁存使能(Command Latch Enable,CLE)和地址锁存使能(Address Latch Enable，ALE)，那是因为，Nand Flash就8个I/O，而且是复用的，也就是，可以传数据，也可以传地址，也可以传命令，为了区分…</em></strong><br><strong><em>Nand flash支持一个叫做CE(chip enable) don’t-care的技术…由于某些外部应用的频率比较低，而Nand Flash内部操作速度比较快…节省功耗…</em></strong><br>参考：<a href="https://zhuanlan.zhihu.com/p/340496845">智能座舱之存储篇第三篇—-NAND Flash 一眼就看明白了</a></p></li><li><p>LUN寻址规则<br><img src="https://s2.loli.net/2024/07/29/Fs5zOQhwPALX26W.png" alt=""></p></li></ul><h2 id="3-QSPI-FLASH"><a href="#3-QSPI-FLASH" class="headerlink" title="3 QSPI FLASH"></a>3 QSPI FLASH</h2><ul><li><p>型号：Infineon(原厂Cypress，2019年被Infineon收购 · 美) S25FL128S<br>容量：128Mb<br>位宽：4b<br><img src="https://s2.loli.net/2024/07/30/M1EioZbzukJIBsL.png" alt=""><br><strong>EHPLC（Enhanced High-Performance Low Command Mode）增强型高性能低命令模式</strong>：<br>功能：EHPLC 模式专注于在最低的命令开销下提供最高的数据传输速率。通过优化命令和数据传输过程，EHPLC 模式能够实现更高的性能，特别是在需要快速读取大量数据的应用中。<br>特点：EHPLC 模式可能会使用更高效的命令集和协议来减少延迟和增加吞吐量，从而提供比传统模式更高的性能。<br><strong>HPLC（High-Performance Low Command Mode）高性能低命令模式</strong>：<br>功能：HPLC 模式也致力于提高数据传输速率，但与 EHPLC 相比，其优化程度可能稍低。HPLC 仍然通过减少命令开销和提高数据传输效率来提供良好的性能。<br>特点：HPLC 模式通常在标准 QSPI 操作的基础上进行一些优化，使其适用于大多数高性能应用，但可能不如 EHPLC 那样极致优化。</p></li><li><p>特征参数<br>注意，这个手册block块=sector扇区<br><img src="https://s2.loli.net/2024/07/30/gMQRPDeht2Ak146.png" alt=""></p></li><li><p>架构<br><img src="https://s2.loli.net/2024/07/30/3FP1fSiHJnlteUG.png" alt=""><br>非常草率的架构图。。。<br><img src="https://s2.loli.net/2024/07/30/OARVLNiy12acW4g.png" alt=""></p></li><li><p>管脚<br><img src="https://s2.loli.net/2024/07/30/M5eVJZ9mFQrfE8z.png" alt=""><br>类似于NAND，QUAD模式4个IO复用指令、地址、数据，并且时分传递。</p></li></ul><h2 id="4-MRAM"><a href="#4-MRAM" class="headerlink" title="4 MRAM"></a>4 MRAM</h2><ul><li><p>型号：EVERSPIN(埃弗斯平 · 美，只做MRAM的小公司，从随意的中文名就可以看出) MR5A16ACYS35<br>容量：32Mb；位宽：16b<br><img src="https://s2.loli.net/2024/07/29/kbTa9m7tzepWUBv.png" alt=""></p></li><li><p>特征参数<br><img src="https://s2.loli.net/2024/07/29/oVRBMi3vUqcyWJe.png" alt=""></p></li><li><p>架构<br><img src="https://s2.loli.net/2024/07/29/tOnjAXr8vdWDmVx.png" alt=""><br>架构图非常简单清晰。<br>“sense amps”（感应放大器）是用来检测和放大存储单元中的信号电压的电路。这些感应放大器的作用是读取MRAM单元的状态，即确定存储单元中存储的是0还是1。具体来说，MRAM的存储单元通过磁性材料的磁化方向来表示数据，而感应放大器则通过检测这些磁化方向造成的电压变化来读取数据。</p></li><li><p>管脚<br><img src="https://s2.loli.net/2024/07/29/TRfj4amweL7qxQg.png" alt=""><br>Output Enable和Write Enable相当于外部输入的读写使能信号。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electronic, memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DJI mini4K拍照模式测试</title>
      <link href="/2024/07/28/dji-mini4k-pai-zhao-mo-shi-ce-shi/"/>
      <url>/2024/07/28/dji-mini4k-pai-zhao-mo-shi-ce-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>主要是天气不错，但是出去骑车又很热，于是闲着没事玩玩mini4K几种照相模式，而且台风格美过境后风力不错，目测偶尔有六级以上，所以作死测试一下其抗风能力。</p><ul><li>全景</li></ul><p>使用这个7年前就断更的开源插件hexo-tag-panoview：<br></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">$ npm install hexo<span class="token operator">-</span>tag<span class="token operator">-</span>panoview <span class="token operator">--</span>save</code></pre><p></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">{</span><span class="token operator">%</span> panoview <span class="token string">"https://s2.loli.net/2024/07/28/QkJsBRyWpc3ECH8.jpg"</span> <span class="token number">400</span> <span class="token number">790</span> <span class="token operator">%</span><span class="token punctuation">}</span><span class="token comment">//400 是指全景的高度；</span><span class="token comment">//790 是指全景的宽度。</span><span class="token punctuation">{</span><span class="token operator">%</span> endpanoview <span class="token operator">%</span><span class="token punctuation">}</span></code></pre><p>得到图片：<br></p><div id="panoview5134" style="margin: 0 auto"></div><script src="https://unpkg.com/three@0.88.0/build/three.min.js"></script><script>    var camera, scene, renderer;    var isUserInteracting = false,        onMouseDownMouseX = 0, onMouseDownMouseY = 0,        lon = 0, onMouseDownLon = 0,        lat = 0, onMouseDownLat = 0,        phi = 0, theta = 0;    init();    animate();    function init() {        var container, mesh;        container = document.getElementById('panoview5134');        var width = container.style.width;        camera = new THREE.PerspectiveCamera(75, 2, 1, 1000);        camera.target = new THREE.Vector3(0, 0, 0);        scene = new THREE.Scene();        var geometry = new THREE.SphereBufferGeometry(500, 60, 40);        // invert the geometry on the x-axis so that all of the faces point inward        geometry.scale(- 1, 1, 1);        var material = new THREE.MeshBasicMaterial({            map: new THREE.TextureLoader().load('https://s2.loli.net/2024/07/28/QkJsBRyWpc3ECH8.jpg')        });        mesh = new THREE.Mesh(geometry, material);        scene.add(mesh);        renderer = new THREE.WebGLRenderer();        renderer.setPixelRatio(window.devicePixelRatio);        renderer.setSize(window.innerWidth, window.innerHeight);        renderer.domElement.style.width = "790px";        renderer.domElement.style.height = "400px";        container.appendChild(renderer.domElement);        container.addEventListener('mousedown', onDocumentMouseDown, false);        container.addEventListener('mousemove', onDocumentMouseMove, false);        container.addEventListener('mouseup', onDocumentMouseUp, false);        // container.addEventListener('wheel', onDocumentMouseWheel, false);        container.addEventListener('dragover', function (event) {            event.preventDefault();            event.dataTransfer.dropEffect = 'copy';        }, false);        container.addEventListener('dragenter', function (event) {            document.body.style.opacity = 0.5;        }, false);        container.addEventListener('dragleave', function (event) {            document.body.style.opacity = 1;        }, false);    }    function onDocumentMouseDown(event) {        event.preventDefault();        isUserInteracting = true;        onMouseDownMouseX = event.clientX;        onMouseDownMouseY = event.clientY;        onMouseDownLon = lon;        onMouseDownLat = lat;    }    function onDocumentMouseMove(event) {        if (isUserInteracting === true) {            lon = (onMouseDownMouseX - event.clientX) * 0.1 + onMouseDownLon;            lat = (event.clientY - onMouseDownMouseY) * 0.1 + onMouseDownLat;        }    }    function onDocumentMouseUp(event) {        isUserInteracting = false;    }    function onDocumentMouseWheel(event) {        var fov = camera.fov + event.deltaY * 0.05;        camera.fov = THREE.Math.clamp(fov, 10, 75);        camera.updateProjectionMatrix();        return false;    }    function animate() {        requestAnimationFrame(animate);        update();    }    function update() {        if (isUserInteracting === false) {            lon += 0.1;        }        lat = Math.max(- 85, Math.min(85, lat));        phi = THREE.Math.degToRad(90 - lat);        theta = THREE.Math.degToRad(lon);        camera.target.x = 500 * Math.sin(phi) * Math.cos(theta);        camera.target.y = 500 * Math.cos(phi);        camera.target.z = 500 * Math.sin(phi) * Math.sin(theta);        camera.lookAt(camera.target);        /*        // distortion        camera.position.copy( camera.target ).negate();        */        renderer.render(scene, camera);    }</script><p></p><p>对比无全景效果，效果居然还不错：<br><img src="https://s2.loli.net/2024/07/28/QkJsBRyWpc3ECH8.jpg" alt=""></p><ul><li>180°</li></ul><p><img src="https://s2.loli.net/2024/07/28/CbeE5f7PvIyTOxX.jpg" alt=""></p><ul><li>广角</li></ul><p><img src="https://s2.loli.net/2024/07/28/R72NqPUspjJzlEA.jpg" alt=""></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>mini4K 1/2.3’’小尺寸CMOS应对广角及以上照片的拍摄方法是分时定位拍摄算法合成</li><li>mini4K抗6级风问题不大</li></ul>]]></content>
      
      
      <categories>
          
          <category> toy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> drone, mini4K </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Using Mathematica for Quantum Mechanics：one particle in one dimension</title>
      <link href="/2024/07/28/using-mathematica-for-quantum-mechanics-one-particle-in-one-dimension/"/>
      <url>/2024/07/28/using-mathematica-for-quantum-mechanics-one-particle-in-one-dimension/</url>
      
        <content type="html"><![CDATA[<h2 id="0-动机"><a href="#0-动机" class="headerlink" title="0 动机"></a>0 动机</h2><p>追求静态网页支持在线mathematica是个错误的方向，直接将笔记上传至mathematica云端就行。但是mathematica的排版一直很难用，就算调用matex包，mathematica依然对latex语言支持很差劲。经过尝试，意外发现它对MathML脚本支持比较完善。另外，将枯燥的standardform转换为traditionalform可以将代码语言转换成公式语言，一定程度上能增加代码可读性。</p><p>然而，一些mathematica的动态或静态图片结果不会加载在云端，需要在云端运行或者下载到本地运行，这就比较麻烦。</p><p><strong>因此，主页放上要点和结论性的图片，同时附上mathematica笔记本链接，会是一个不错的结合。</strong></p><p><a href="https://www.wolframcloud.com/env/wya1759991046/Published/Use%20mathematica%20for%20QM%204.1.1_4.1.6.nb">mathematica笔记本链接</a></p><h2 id="1-要点"><a href="#1-要点" class="headerlink" title="1 要点"></a>1 要点</h2><ul><li>finite-resolution position basis(FRPS/PS)本质上是对Dirac basis的采样</li><li>PS是离散的，和momentum basis(MS)的关系为：基系数互为DST-1变换(type-1 discrete sine transform)</li><li>有一些算符用MS展开简单，另一些用PS展开简单，例如动能算符用MS展开简单，势能算符用PS展开简单。求得一种展开，另一种展开通过DST-1变换就行了。</li></ul><h2 id="2-视觉知识"><a href="#2-视觉知识" class="headerlink" title="2 视觉知识"></a>2 视觉知识</h2><ul><li>MB的归一正交性验证</li></ul><p><img src="https://s2.loli.net/2024/07/28/X2Pc3BZMUw4mohe.png" alt=""></p><ul><li>MB的完备性验证</li></ul><p><img src="https://s2.loli.net/2024/07/28/opAHTkgm5Q694Nl.gif" alt=""></p><ul><li>PB在Dirac Basis中的展开系数</li></ul><p><img src="https://s2.loli.net/2024/07/28/XMpgNf9iU1YqwHz.gif" alt=""></p><ul><li>$\hat{\mathcal{x}}$在MB展开</li></ul><p><img src="https://s2.loli.net/2024/07/28/rOIfuNoX6vKd2Qx.png" alt=""></p><ul><li>$\hat{\mathcal{x}}$在PB展开</li></ul><p><img src="https://s2.loli.net/2024/07/28/LvRpePJoAmKzCiH.png" alt=""> </p><ul><li>$\hat{\mathcal{T}}$在MB展开</li></ul><p><img src="https://s2.loli.net/2024/07/28/McX5g7bmaxYnKGr.png" alt=""></p><ul><li>$\hat{\mathcal{T}}$在PB展开</li></ul><p><img src="https://s2.loli.net/2024/07/28/2NG6qnwhYiFUvP1.png" alt=""></p><ul><li>$\hat{\mathcal{P}}$在MB展开，可以发现只有虚部</li></ul><p><img src="https://s2.loli.net/2024/07/28/yUav1CXTif6bsRq.png" alt=""></p><ul><li>$\hat{\mathcal{P}}$在PB展开，可以发现只有虚部</li></ul><p><img src="https://s2.loli.net/2024/07/28/1Qr4ztxgvTuUXL3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathematica, quantum mechanics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Using Mathematica for Quantum Mechanics：states and operators</title>
      <link href="/2024/07/24/using-mathematica-for-quantum-mechanics-states-and-operators/"/>
      <url>/2024/07/24/using-mathematica-for-quantum-mechanics-states-and-operators/</url>
      
        <content type="html"><![CDATA[<h2 id="0-动机"><a href="#0-动机" class="headerlink" title="0 动机"></a>0 动机</h2><p>这是我的第一篇博客，没有获奖感言，锻炼下markdown使用以及测试下hexo-renderer-kramed渲染器的稳定性倒是有必要的。</p><hr><p><em>‘The limits of my language mean the limits of my world.’</em> —— Ludwig Wittgenstein</p><p>量子力学数学语言和代码语言之间的关系是什么？</p><h2 id="1-基矢的表示"><a href="#1-基矢的表示" class="headerlink" title="1 基矢的表示"></a>1 基矢的表示</h2><h3 id="1-1-算符和量子态的计算机语言"><a href="#1-1-算符和量子态的计算机语言" class="headerlink" title="1.1 算符和量子态的计算机语言"></a>1.1 算符和量子态的计算机语言</h3><script type="math/tex; mode=display">\hat{\mathcal{A}}=\sum_{ij}A_{ij} |i\rangle\langle j|,</script><script type="math/tex; mode=display">|\psi\rangle=\sum_i\psi_i|i\rangle,</script><h3 id="1-2-有限空间的处理方法"><a href="#1-2-有限空间的处理方法" class="headerlink" title="1.2 有限空间的处理方法"></a>1.2 有限空间的处理方法</h3><script type="math/tex; mode=display">\hat{\mathcal{A}}=\mathbb{1} \cdot \hat{\mathcal{A}} \cdot \mathbb{1}=(\hat{P}+\hat{Q}) \cdot \hat{\mathcal{A}} \cdot(\hat{P}+\hat{Q})=\hat{P} \cdot \hat{\mathcal{A}} \cdot \hat{P}+\hat{P} \cdot \hat{\mathcal{A}} \cdot \hat{Q}+\hat{Q} \cdot \hat{\mathcal{A}} \cdot \hat{P}+\hat{Q} \cdot \hat{\mathcal{A}} \cdot \hat{Q} \\= \underbrace{\sum_{i j} A_{i j}|i\rangle\langle j|}_{\text {within described subspace }}+\underbrace{\hat{P} \cdot \hat{\mathcal{A}} \cdot \hat{Q}+\hat{Q} \cdot \hat{\mathcal{A}} \cdot \hat{P}}_{\text {neglected coupling to (high-energy) part }}+\underbrace{\hat{Q} \cdot \hat{\mathcal{A}} \cdot \hat{Q}}_{\text {neglected (high-energy) part }},</script><script type="math/tex; mode=display">|\psi\rangle=1\cdot|\psi\rangle=(\hat{P}+\hat{Q})\cdot|\psi\rangle=\underbrace{\sum_i\psi_i |i\rangle}_{\text{within described subspace}}+\underbrace{\hat{Q}|\psi\rangle}_{\text{neglected (high-energy) part}}.</script><h2 id="2-时不变薛定谔方程"><a href="#2-时不变薛定谔方程" class="headerlink" title="2 时不变薛定谔方程"></a>2 时不变薛定谔方程</h2><p>数学语言为：</p><script type="math/tex; mode=display">\hat{\mathcal{H}}|\psi\rangle=E|\psi\rangle,</script><p><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\sum_jH_{mj}\psi_j=E\psi_m,</script><p>其向量形式为$H\cdot\vec{\psi}=E\vec{\boldsymbol{\psi}}$.</p><h2 id="3-时变薛定谔方程"><a href="#3-时变薛定谔方程" class="headerlink" title="3 时变薛定谔方程"></a>3 时变薛定谔方程</h2><p>数学语言为：</p><script type="math/tex; mode=display">\mathrm{i}\hbar\frac{\mathrm{d}}{\mathrm{d}t}|\psi(t)\rangle=\hat{\mathcal{H}}(t)|\psi(t)\rangle,</script><p>解方程得到：<br>$|\psi(t)\rangle=\hat{\mathcal{U}}(t_0;t)|\psi(t_0)\rangle$, 其中$\hat{\mathcal{U}}(t_0;t)$为传播子，对其用Magnus expansion得到$\hat{\mathcal{U}}(t_0;t)=\exp\left[\sum_{k=1}^\infty\hat{\Omega}_k(t_0;t)\right]$.</p><h3 id="3-1-假设基矢时不变，去解方程"><a href="#3-1-假设基矢时不变，去解方程" class="headerlink" title="3.1 假设基矢时不变，去解方程"></a>3.1 假设基矢时不变，去解方程</h3><p>假设$\hat{\mathcal{H}}(t)=\sum_{ij}H_{ij}(t) |i\rangle\langle j|$, $|\psi(t)\rangle=\sum\psi_i(t)\mid i\rangle$, 带入时变薛定谔方程，可以得到<br><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\mathrm{i}\hbar\dot{\psi}_m(t)=\sum_kH_{mk}(t)\psi_k(t),</script><p>其向量形式为$\mathrm{i}\hbar\dot{\vec{\boldsymbol{\psi}}}(t)=H(t)\cdot\vec{\boldsymbol{\psi}}(t)$.</p><h3 id="3-2-假设基矢时变，去解方程（用于相互作用图景）"><a href="#3-2-假设基矢时变，去解方程（用于相互作用图景）" class="headerlink" title="3.2 假设基矢时变，去解方程（用于相互作用图景）"></a>3.2 假设基矢时变，去解方程（用于相互作用图景）</h3><p>相互作用下哈密顿量为：$\hat{\mathcal{H}}(t)=\hat{\mathcal{H}}_0+\hat{\mathcal{H}}_1(t)$. 假设$\hat{\mathcal{H}}_0$可以对角化，即$\hat{\mathcal{H}}_0|i\rangle=E_i|i\rangle$, 则时变基矢表达式为：$|i(t)\rangle=e^{-\mathrm{i}E_it/\hbar}|i\rangle$, 于是可以将量子态用时变基展开：</p><script type="math/tex; mode=display">|\psi(t)\rangle=\sum_i\psi_i(t)\mid i(t)\rangle=\sum_i\psi_i(t)e^{-\mathrm{i}E_it/\hbar}|i\rangle,</script><p>将之带入时变薛定谔方程，可以得到<br><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\mathrm{i}\hbar\dot{\psi}_k(t)=\sum_j\psi_j(t)e^{-\mathrm{i}(E_j-E_k)t/\hbar}\langle k|\hat{\mathcal{H}}_1(t)|j\rangle=\sum_j\psi_j(t)e^{-\mathrm{i}(E_j-E_k)t/\hbar}{\mathcal{H}}_{1_{kj}}(t).</script><h3 id="3-3-特殊情况：-left-hat-mathcal-H-t-hat-mathcal-H-t’-right-0-forall-t-t’"><a href="#3-3-特殊情况：-left-hat-mathcal-H-t-hat-mathcal-H-t’-right-0-forall-t-t’" class="headerlink" title="3.3 特殊情况： $\left[\hat{\mathcal{H}}(t),\hat{\mathcal{H}}(t’)\right]=0 \forall(t,t’)$"></a>3.3 特殊情况： $\left[\hat{\mathcal{H}}(t),\hat{\mathcal{H}}(t’)\right]=0 \forall(t,t’)$</h3><p>可以直接解出薛定谔方程，其<br><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\vec{\boldsymbol{\psi}}(t)=\exp\left[-\frac{\mathrm{i}}{\hbar}\int_{t_0}^t\boldsymbol{H}(s)\mathrm{d}s\right]\cdot\vec{\boldsymbol{\psi}}(t_0).</script><h3 id="3-4-特殊情况：-哈密顿量是时不变的"><a href="#3-4-特殊情况：-哈密顿量是时不变的" class="headerlink" title="3.4 特殊情况： 哈密顿量是时不变的"></a>3.4 特殊情况： 哈密顿量是时不变的</h3><p>可以直接解出薛定谔方程，其<br><strong>计算机语言</strong>为：</p><script type="math/tex; mode=display">\vec{\boldsymbol{\psi}}(t)=\exp\left[-\frac{\mathrm{i}(t-t_0)}\hbar\boldsymbol{H}\right]\cdot\vec{\boldsymbol{\psi}}(t_0).</script><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">phi:= = Flatten[KroneckerProduct[ phi1, phi2, phi3]]</code></pre><h2 id="4-基矢的计算机构造"><a href="#4-基矢的计算机构造" class="headerlink" title="4 基矢的计算机构造"></a>4 基矢的计算机构造</h2><h3 id="4-1-多维系统的描述"><a href="#4-1-多维系统的描述" class="headerlink" title="4.1 多维系统的描述"></a>4.1 多维系统的描述</h3><p>多维量子态的数学描述如下：</p><script type="math/tex; mode=display">\begin{aligned}|\psi\rangle=\left[\sum_{i_1=1}^{n_1}\psi_{i_1}^{(1)}|i_1\rangle^{(1)}\right]\otimes\left[\sum_{i_2=1}^{n_2}\psi_{i_2}^{(2)}|i_2\rangle^{(2)}\right]\otimes\cdots\otimes\left[\sum_{i_N=1}^{n_N}\psi_{i_N}^{(N)}|i_N\rangle^{(N)}\right]\\&\\=\sum_{i_1=1}^{n_1}\sum_{i_2=1}^{n_2}\cdots\sum_{i_N=1}^{n_N}\left[\psi_{i_1}^{(1)}\psi_{i_2}^{(2)}\ldots\psi_{i_N}^{(N)}\right]|i_1,i_2,\ldots,i_N\rangle\end{aligned},</script><p><strong>计算机语言</strong>为：<br></p><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">U[∆t_?NumericQ] := MatrixExp[-I*H*N[∆t]/~]</code></pre><br>多维算符的数学描述如下：<p></p><script type="math/tex; mode=display">\begin{aligned}\hat{A}=\left[\sum_{i_{1}=1}^{n_{1}}\sum_{j_{1}=1}^{n_{1}}a_{i_{1},j_{1}}^{(1)}|i_{1}\rangle^{(1)}\langle j_{1}|^{(1)}\right]\otimes\left[\sum_{i_{2}=1}^{n_{2}}\sum_{j_{2}=1}^{n_{2}}a_{i_{2},j_{2}}^{(2)}|i_{2}\rangle^{(2)}\langle j_{2}|^{(2)}\right]\otimes\cdots\otimes\left[\sum_{i_{N}=1}^{n_{N}}\sum_{i_{N}=1}^{n_{N}}a_{i_{N},j_{N}}^{(N)}|i_{N}\rangle^{(N)}\langle j_{N}|^{(N)}\right]\\&\\=\sum_{i_{1}=1}^{n_{1}}\sum_{j_{1}=1}^{n_{1}}\sum_{i_{2}=1}^{n_{2}}\sum_{j_{2}=1}^{n_{2}}\cdots\sum_{i_{N}=1}^{n_{N}}\sum_{j_{N}=1}^{n_{N}}\left[a_{i_{1}j_{1}}^{(1)}a_{i_{2}j_{2}}^{(2)}\cdots a_{i_{N}j_{N}}^{(N)}\right]|i_{1},i_{2},\ldots,i_{N}\rangle\langle j_{1},j_{2},\ldots,j_{N}|.\end{aligned}</script><p><strong>计算机语言</strong>为：<br></p><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">A = KroneckerProduct[a1, a2, a3]</code></pre><br>我们经常考察作用在某一成员空间的算符，这种算符的<br><strong>计算机语言</strong>（假设为三体系统）为<br><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">H1 = KroneckerProduct[h1,                    IdentityMatrix[Dimensions[h2]],                    IdentityMatrix[Dimensions[h3]]];H2 = KroneckerProduct[IdentityMatrix[Dimensions[h1]],                    h2,                    IdentityMatrix[Dimensions[h3]]];H3 = KroneckerProduct[IdentityMatrix[Dimensions[h1]],                    IdentityMatrix[Dimensions[h2]],                    h3];</code></pre><p></p><h3 id="4-2-偏迹的描述"><a href="#4-2-偏迹的描述" class="headerlink" title="4.2 偏迹的描述"></a>4.2 偏迹的描述</h3><p>数学描述如下，假如有一个三体系统：</p><script type="math/tex; mode=display">\hat{\rho}_{\mathrm{ABC}}=\sum_{i,i^{\prime}=1}^{d_{\mathrm{A}}}\sum_{j,j^{\prime}=1}^{d_{\mathrm{B}}}\sum_{k,k^{\prime}=1}^{d_{\mathrm{C}}}\rho_{i,j,k,i^{\prime},j^{\prime},k^{\prime}}|i_{\mathrm{A}},j_{\mathrm{B}},k_{\mathrm{C}}\rangle\langle i_{\mathrm{A}}^{\prime},j_{\mathrm{B}}^{\prime},k_{\mathrm{C}}^{\prime}|,</script><p>其中$\rho$是个6维张量。对B求偏迹的数学公式为：</p><script type="math/tex; mode=display">\begin{gathered}\hat{\rho}_{\mathrm{AC}}=\sum_{j^{\prime\prime}=1}^{d_{\mathrm{B}}}\langle j_{\mathrm{B}}^{\prime\prime}|\hat{\rho}_{\mathrm{ABC}}|j_{\mathrm{B}}^{\prime\prime}\rangle\\=\sum_{j^{\prime\prime}=1}^{d_{\mathrm{B}}}\langle j_{\mathrm{B}}^{\prime\prime}|\left\lfloor\sum_{i,i^{\prime}=1}^{d_{\mathrm{A}}}\sum_{j,j^{\prime}=1}^{d_{\mathrm{B}}}\sum_{k,k^{\prime}=1}^{d_{\mathrm{C}}}\rho_{i,j,k,i^{\prime},j^{\prime},k^{\prime}}|i_{\mathrm{A}},j_{\mathrm{B}},k_{\mathrm{C}}\rangle\langle i_{\mathrm{A}}^{\prime},j_{\mathrm{B}}^{\prime},k_{\mathrm{C}}^{\prime}|\right\rfloor|j_{\mathrm{B}}^{\prime\prime}\rangle \\=\sum_{j^{\prime\prime}=1}^{d_{B}}\sum_{i,i^{\prime}=1}^{d_{A}}\sum_{j,j=1}^{d_{B}}\sum_{k,k^{\prime}=1}^{d_{C}}\rho_{i,j,k,i^{\prime},j^{\prime},k^{\prime}}\langle j_{B}^{\prime\prime}|i_{A},j_{B},k_{C}\rangle\langle i_{A}^{\prime},j_{B}^{\prime},k_{C}^{\prime}|j_{B}^{\prime\prime}\rangle\\=\sum_{j^{\prime\prime}=1}^{d_{B}}\sum_{i,i^{\prime}=1}^{d_{A}}\sum_{j,j^{\prime}=1}^{d_{B}}\sum_{k,k^{\prime}=1}^{d_{C}}\rho_{i,j,k,i^{\prime},j^{\prime},k^{\prime}}[\delta_{j^{\prime\prime},j}|i_{A},k_{C}\rangle]\left[\delta_{j^{\prime\prime},j^{\prime}}\langle i_{A}^{\prime},k_{C}^{\prime}\right|] \\=\sum_{i,i^{\prime}=1}^{d_{A}}\sum_{k,k^{\prime}=1}^{d_{C}}\left[\sum_{j=1}^{d_{B}}\rho_{i,j,k,i^{\prime},j,k^{\prime}}\right]|i_{A},k_{C}\rangle\langle i_{A}^{\prime},k_{C}^{\prime}|,\end{gathered}</script><p>可见这是对6维张量在2&amp;5维上的压缩操作。<br>所以用<strong>计算机语言</strong>去表示偏迹，可以先把$\hat{\rho}_{\mathrm{ABC}}$重塑成6维张量：<br></p><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">R = ArrayReshape[ρABC, {dA,dB,dC,dA,dB,dC}]</code></pre><br>然后在2&amp;5维上进行压缩操作：<br><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">S = TensorContract[R, {2,5}]</code></pre><br>最后再还原成密度矩阵形式(2维张量)：<br><pre class="language-wolfram" data-language="wolfram"><code class="language-wolfram">ρAC = Flatten[S, {{1,2}, {3,4}}]</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathematica, quantum mechanics </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
